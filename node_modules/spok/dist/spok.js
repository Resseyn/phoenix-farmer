"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const ansicolors_1 = __importDefault(require("ansicolors"));
const assert_1 = require("assert");
const inspect_1 = __importDefault(require("./inspect"));
const spok_assertions_1 = __importDefault(require("./spok-assertions"));
const types_internal_1 = require("./types-internal");
const utils_1 = require("./utils");
__exportStar(require("./types"), exports);
const adapter_chai_expect_1 = require("./adapter-chai-expect");
const strip_ansi_1 = __importDefault(require("./strip-ansi"));
// When we're running as part of node --test we need to disable colors even if
// the user them to be on as otherwise TAP output becomes invalid.
// NOTE: we start not printing colors in order to avoid screwing up the output
// until we're sure.
// We hope that this resolves before too many colorless diagnostics were printed.
let disableColor = true;
(function () {
    if ((0, utils_1.isForcingColor)()) {
        disableColor = false;
    }
    else {
        (0, utils_1.isRunningAsTestChildProcess)().then((x) => {
            disableColor = x;
        });
    }
})();
// only recurse into arrays if they contain actual specs or objects
function needRecurseArray(arr) {
    for (const el of arr) {
        if (typeof el !== 'number' && typeof el !== 'string' && el != null) {
            return true;
        }
    }
    return false;
}
function needRecurse(spec) {
    if (Array.isArray(spec))
        return needRecurseArray(spec);
    if (spec == null)
        return false;
    const keys = Object.keys(spec);
    if (keys.length === 0)
        return false;
    // if no spok functions are part of the spec, we could use deepEqual, but
    // we get a more fine grained output if we recurse even if the spec values
    // are constants
    return true;
}
/**
 * Checks the given specifications against the object.
 *
 * When the tests are run the **actual** values are printed
 * to verify visually while each provided specification is validated
 * and a test failure caused if one of them fails.
 *
 * @function
 *
 * @param {Object} t which has assertion functions `equal` and
 * `deepEqual` (to compare objects) - use * **tap**, **tape**,
 * **assert** or any other library that has those and thus is compatible
 *
 * @param {Object} obj the object to verify the specifications against
 * @param {Specifications} specifications the specifications to verify
 * @param {String } prefix added to messages
 */
const spokFunction = (t, obj, specifications, prefix = '') => {
    const isCtx = (0, types_internal_1.isTestContext)(t);
    const _assert = isCtx ? assert_1.strict : t;
    const color = spok.color && !disableColor;
    function check(k) {
        if (k === '$topic' || k === '$spec' || k === '$description')
            return;
        // @ts-ignore
        const spec = specifications[k];
        if (obj == null) {
            let summary = `property "${k}" checked on null or undefined`;
            let description = ', this is most likely due to an array in' +
                ' the specs that has more items than the actual array';
            if (color) {
                summary = ansicolors_1.default.red(summary);
                description = ansicolors_1.default.brightBlack(description);
            }
            const msg = `${summary}${description}`;
            if (isCtx)
                t.diagnostic(msg);
            return _assert.equal(spec, obj, msg);
        }
        // @ts-ignore
        const val = obj[k];
        let msg = prefix + k + ' = ' + (0, inspect_1.default)(val, color);
        if (spec != null) {
            if (spec.$spec == null && spec.name != null && spec.name.length > 0) {
                spec.$spec = spec.name;
            }
            const ps = spok.printSpec && spec.$spec != null;
            const pd = spok.printDescription && spec.$description != null;
            if (ps) {
                const extra = '  ' + 'satisfies: ' + spec.$spec;
                msg += color ? ansicolors_1.default.brightBlack(extra) : (0, strip_ansi_1.default)(extra);
            }
            if (pd) {
                msg += color
                    ? '  ' + ansicolors_1.default.brightBlack(spec.$description)
                    : '  ' + (0, strip_ansi_1.default)(spec.$description);
            }
        }
        switch (typeof spec) {
            case 'function':
                if (isCtx)
                    t.diagnostic(msg);
                return _assert.equal(!!spec(val), true, msg);
            case 'boolean':
            case 'number':
            case 'string':
                if (isCtx)
                    t.diagnostic(msg);
                return _assert.equal(val, spec, msg);
            case 'object':
                if (spec == null) {
                    if (isCtx)
                        t.diagnostic(msg);
                    return _assert.equal(val, spec, msg);
                }
                if (!needRecurse(spec)) {
                    if (isCtx)
                        t.diagnostic(msg);
                    return _assert.deepEqual(val, spec, msg);
                }
                if (spec.$topic == null) {
                    const rootTopic = specifications.$topic != null ? specifications.$topic + '.' : '';
                    spec.$topic = rootTopic + k;
                }
                return spok(t, val, spec, prefix);
            default:
                throw new Error('at key "' +
                    k +
                    '" Type ' +
                    typeof spec +
                    ' not yet handled. Please submit a PR');
        }
    }
    if (specifications.$topic != null) {
        // print indicator that a specific spec started being evaluated
        const msg = prefix + 'spok: ' + specifications.$topic;
        if (isCtx) {
            t.diagnostic(msg);
        }
        else {
            _assert.equal(1, 1, msg);
        }
        prefix = (prefix !== null && prefix !== void 0 ? prefix : '') + (color ? '·· ' : '.. ');
    }
    // check all specs
    Object.keys(specifications).forEach(check);
    // provide confirmation that spec is done
    if (spok.sound) {
        require('child_process').execSync('say spokie dokie -v Vicki -r 600');
    }
};
/**
 * Version of `spok` that is less strict about the relation of the
 * specification type, namely it allows overriding the type manually or
 * derives it from the supplied parameter.
 *
 * Use ONLY when you cannot adjust the types, so plain `spok` works.
 *
 */
const spokFunctionAny = (t, obj, specifications, prefix = '') => {
    return spokFunction(t, obj, specifications, prefix);
};
const noColorEnvVar = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NO_COLOR;
const spokConfig = {
    printSpec: true,
    printDescription: false,
    sound: false,
    color: noColorEnvVar != '1' && noColorEnvVar != 'true',
};
const spok = Object.assign(spokFunction, { any: spokFunctionAny }, spok_assertions_1.default, spokConfig, { adapters: { chaiExpect: adapter_chai_expect_1.chaiExpect } });
exports.default = spok;
//# sourceMappingURL=spok.js.map