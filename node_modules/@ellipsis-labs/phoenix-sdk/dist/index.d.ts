import * as web3 from '@solana/web3.js';
import { PublicKey, Connection, TransactionInstruction, Transaction, Commitment, TransactionSignature, ParsedTransactionWithMeta } from '@solana/web3.js';
import * as beet from '@metaplex-foundation/beet';
import { bignum } from '@metaplex-foundation/beet';
import BN from 'bn.js';
import { BinaryReader } from 'borsh';

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */
type ErrorWithCode = Error & {
    code: number;
};
type MaybeErrorWithCode = ErrorWithCode | null | undefined;
/**
 * InvalidMarketParameters: 'Invalid market parameters error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMarketParametersError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMarketAuthority: 'Invalid exchange authority error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMarketAuthorityError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * FailedToLoadMarketFromAccount: 'Market deserialization error'
 *
 * @category Errors
 * @category generated
 */
declare class FailedToLoadMarketFromAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * MarketAlreadyInitialized: 'Market already initialized error'
 *
 * @category Errors
 * @category generated
 */
declare class MarketAlreadyInitializedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * MarketUninitialized: 'Market is not initialized error'
 *
 * @category Errors
 * @category generated
 */
declare class MarketUninitializedError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidStateTransition: 'Invalid state transition error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidStateTransitionError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMarketSigner: 'Invalid market signer error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMarketSignerError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidLotSize: 'Invalid lot size error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidLotSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidTickSize: 'Invalid tick size error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidTickSizeError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidMint: 'Invalid mint error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidMintError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidBaseVault: 'Invalid base vault error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidBaseVaultError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidQuoteVault: 'Invalid quote vault error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidQuoteVaultError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidBaseAccount: 'Invalid base account error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidBaseAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidQuoteAccount: 'Invalid quote account error'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidQuoteAccountError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TooManyEvents: 'Too many events error'
 *
 * @category Errors
 * @category generated
 */
declare class TooManyEventsError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * NewOrderError: 'New order error'
 *
 * @category Errors
 * @category generated
 */
declare class NewOrderErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * ReduceOrderError: 'Reduce order error'
 *
 * @category Errors
 * @category generated
 */
declare class ReduceOrderErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * CancelMultipleOrdersError: 'Cancel multiple orders error'
 *
 * @category Errors
 * @category generated
 */
declare class CancelMultipleOrdersErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * WithdrawFundsError: 'Withdraw funds error'
 *
 * @category Errors
 * @category generated
 */
declare class WithdrawFundsErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * RemoveEmptyOrdersError: 'Remove empty orders error'
 *
 * @category Errors
 * @category generated
 */
declare class RemoveEmptyOrdersErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * TraderNotFound: 'Trader not found error'
 *
 * @category Errors
 * @category generated
 */
declare class TraderNotFoundError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * InvalidSeatStatus: 'Invalid seat status'
 *
 * @category Errors
 * @category generated
 */
declare class InvalidSeatStatusError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * EvictionError: 'Failed to evict trader'
 *
 * @category Errors
 * @category generated
 */
declare class EvictionErrorError extends Error {
    readonly code: number;
    readonly name: string;
    constructor();
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
declare function errorFromCode(code: number): MaybeErrorWithCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
declare function errorFromName(name: string): MaybeErrorWithCode;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type AuditLogHeader = {
    instruction: number;
    sequenceNumber: beet.bignum;
    timestamp: beet.bignum;
    slot: beet.bignum;
    market: web3.PublicKey;
    signer: web3.PublicKey;
    totalEvents: number;
};
/**
 * @category userTypes
 * @category generated
 */
declare const auditLogHeaderBeet: beet.BeetArgsStruct<AuditLogHeader>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum Side {
    Bid = 0,
    Ask = 1
}
/**
 * @category userTypes
 * @category generated
 */
declare const sideBeet: beet.FixedSizeBeet<Side, Side>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CancelOrderParams = {
    side: Side;
    priceInTicks: beet.bignum;
    orderSequenceNumber: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const cancelOrderParamsBeet: beet.BeetArgsStruct<CancelOrderParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CancelMultipleOrdersByIdParams = {
    orders: CancelOrderParams[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const cancelMultipleOrdersByIdParamsBeet: beet.FixableBeetArgsStruct<CancelMultipleOrdersByIdParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CancelUpToParams = {
    side: Side;
    tickLimit: beet.COption<beet.bignum>;
    numOrdersToSearch: beet.COption<number>;
    numOrdersToCancel: beet.COption<number>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const cancelUpToParamsBeet: beet.FixableBeetArgsStruct<CancelUpToParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type CondensedOrder = {
    priceInTicks: beet.bignum;
    sizeInBaseLots: beet.bignum;
    lastValidSlot: beet.COption<beet.bignum>;
    lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const condensedOrderBeet: beet.FixableBeetArgsStruct<CondensedOrder>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type DepositParams = {
    quoteLotsToDeposit: beet.bignum;
    baseLotsToDeposit: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const depositParamsBeet: beet.BeetArgsStruct<DepositParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type EvictEvent = {
    index: number;
    makerId: web3.PublicKey;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsEvicted: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const evictEventBeet: beet.BeetArgsStruct<EvictEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ExpiredOrderEvent = {
    index: number;
    makerId: web3.PublicKey;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsRemoved: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const expiredOrderEventBeet: beet.BeetArgsStruct<ExpiredOrderEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FeeEvent = {
    index: number;
    feesCollectedInQuoteLots: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const feeEventBeet: beet.BeetArgsStruct<FeeEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FillEvent = {
    index: number;
    makerId: web3.PublicKey;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsFilled: beet.bignum;
    baseLotsRemaining: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const fillEventBeet: beet.BeetArgsStruct<FillEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type FillSummaryEvent = {
    index: number;
    clientOrderId: beet.bignum;
    totalBaseLotsFilled: beet.bignum;
    totalQuoteLotsFilled: beet.bignum;
    totalFeeInQuoteLots: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const fillSummaryEventBeet: beet.BeetArgsStruct<FillSummaryEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MarketSizeParams = {
    bidsSize: beet.bignum;
    asksSize: beet.bignum;
    numSeats: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const marketSizeParamsBeet: beet.BeetArgsStruct<MarketSizeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type InitializeParams = {
    marketSizeParams: MarketSizeParams;
    numQuoteLotsPerQuoteUnit: beet.bignum;
    tickSizeInQuoteLotsPerBaseUnit: beet.bignum;
    numBaseLotsPerBaseUnit: beet.bignum;
    takerFeeBps: number;
    feeCollector: web3.PublicKey;
    rawBaseUnitsPerBaseUnit: beet.COption<number>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const initializeParamsBeet: beet.FixableBeetArgsStruct<InitializeParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TokenParams = {
    decimals: number;
    vaultBump: number;
    mintKey: web3.PublicKey;
    vaultKey: web3.PublicKey;
};
/**
 * @category userTypes
 * @category generated
 */
declare const tokenParamsBeet: beet.BeetArgsStruct<TokenParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MarketHeader = {
    discriminant: beet.bignum;
    status: beet.bignum;
    marketSizeParams: MarketSizeParams;
    baseParams: TokenParams;
    baseLotSize: beet.bignum;
    quoteParams: TokenParams;
    quoteLotSize: beet.bignum;
    tickSizeInQuoteAtomsPerBaseUnit: beet.bignum;
    authority: web3.PublicKey;
    feeRecipient: web3.PublicKey;
    marketSequenceNumber: beet.bignum;
    successor: web3.PublicKey;
    rawBaseUnitsPerBaseUnit: number;
    padding1: number;
    padding2: beet.bignum[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const marketHeaderBeet: beet.BeetArgsStruct<MarketHeader>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum MarketStatus {
    Uninitialized = 0,
    Active = 1,
    PostOnly = 2,
    Paused = 3,
    Closed = 4,
    Tombstoned = 5
}
/**
 * @category userTypes
 * @category generated
 */
declare const marketStatusBeet: beet.FixedSizeBeet<MarketStatus, MarketStatus>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum FailedMultipleLimitOrderBehavior {
    FailOnInsufficientFundsAndAmendOnCross = 0,
    FailOnInsufficientFundsAndFailOnCross = 1,
    SkipOnInsufficientFundsAndAmendOnCross = 2,
    SkipOnInsufficientFundsAndFailOnCross = 3
}
/**
 * @category userTypes
 * @category generated
 */
declare const failedMultipleLimitOrderBehaviorBeet: beet.FixedSizeBeet<FailedMultipleLimitOrderBehavior, FailedMultipleLimitOrderBehavior>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type MultipleOrderPacket = {
    bids: CondensedOrder[];
    asks: CondensedOrder[];
    clientOrderId: beet.COption<beet.bignum>;
    failedMultipleLimitOrderBehavior: FailedMultipleLimitOrderBehavior;
};
/**
 * @category userTypes
 * @category generated
 */
declare const multipleOrderPacketBeet: beet.FixableBeetArgsStruct<MultipleOrderPacket>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum SelfTradeBehavior {
    Abort = 0,
    CancelProvide = 1,
    DecrementTake = 2
}
/**
 * @category userTypes
 * @category generated
 */
declare const selfTradeBehaviorBeet: beet.FixedSizeBeet<SelfTradeBehavior, SelfTradeBehavior>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link OrderPacket} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link OrderPacket} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type OrderPacketRecord = {
    PostOnly: {
        side: Side;
        priceInTicks: beet.bignum;
        numBaseLots: beet.bignum;
        clientOrderId: beet.bignum;
        rejectPostOnly: boolean;
        useOnlyDepositedFunds: boolean;
        lastValidSlot: beet.COption<beet.bignum>;
        lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
        failSilentlyOnInsufficientFunds: boolean;
    };
    Limit: {
        side: Side;
        priceInTicks: beet.bignum;
        numBaseLots: beet.bignum;
        selfTradeBehavior: SelfTradeBehavior;
        matchLimit: beet.COption<beet.bignum>;
        clientOrderId: beet.bignum;
        useOnlyDepositedFunds: boolean;
        lastValidSlot: beet.COption<beet.bignum>;
        lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
        failSilentlyOnInsufficientFunds: boolean;
    };
    ImmediateOrCancel: {
        side: Side;
        priceInTicks: beet.COption<beet.bignum>;
        numBaseLots: beet.bignum;
        numQuoteLots: beet.bignum;
        minBaseLotsToFill: beet.bignum;
        minQuoteLotsToFill: beet.bignum;
        selfTradeBehavior: SelfTradeBehavior;
        matchLimit: beet.COption<beet.bignum>;
        clientOrderId: beet.bignum;
        useOnlyDepositedFunds: boolean;
        lastValidSlot: beet.COption<beet.bignum>;
        lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
    };
};
/**
 * Union type respresenting the OrderPacket data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isOrderPacket*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type OrderPacket = beet.DataEnumKeyAsKind<OrderPacketRecord>;
declare const isOrderPacketPostOnly: (x: OrderPacket) => x is {
    __kind: "PostOnly";
} & Omit<{
    side: Side;
    priceInTicks: beet.bignum;
    numBaseLots: beet.bignum;
    clientOrderId: beet.bignum;
    rejectPostOnly: boolean;
    useOnlyDepositedFunds: boolean;
    lastValidSlot: beet.COption<beet.bignum>;
    lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
    failSilentlyOnInsufficientFunds: boolean;
}, "void"> & {
    __kind: "PostOnly";
};
declare const isOrderPacketLimit: (x: OrderPacket) => x is {
    __kind: "Limit";
} & Omit<{
    side: Side;
    priceInTicks: beet.bignum;
    numBaseLots: beet.bignum;
    selfTradeBehavior: SelfTradeBehavior;
    matchLimit: beet.COption<beet.bignum>;
    clientOrderId: beet.bignum;
    useOnlyDepositedFunds: boolean;
    lastValidSlot: beet.COption<beet.bignum>;
    lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
    failSilentlyOnInsufficientFunds: boolean;
}, "void"> & {
    __kind: "Limit";
};
declare const isOrderPacketImmediateOrCancel: (x: OrderPacket) => x is {
    __kind: "ImmediateOrCancel";
} & Omit<{
    side: Side;
    priceInTicks: beet.COption<beet.bignum>;
    numBaseLots: beet.bignum;
    numQuoteLots: beet.bignum;
    minBaseLotsToFill: beet.bignum;
    minQuoteLotsToFill: beet.bignum;
    selfTradeBehavior: SelfTradeBehavior;
    matchLimit: beet.COption<beet.bignum>;
    clientOrderId: beet.bignum;
    useOnlyDepositedFunds: boolean;
    lastValidSlot: beet.COption<beet.bignum>;
    lastValidUnixTimestampInSeconds: beet.COption<beet.bignum>;
}, "void"> & {
    __kind: "ImmediateOrCancel";
};
/**
 * @category userTypes
 * @category generated
 */
declare const orderPacketBeet: beet.FixableBeet<OrderPacket, OrderPacket>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type PlaceEvent = {
    index: number;
    orderSequenceNumber: beet.bignum;
    clientOrderId: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsPlaced: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const placeEventBeet: beet.BeetArgsStruct<PlaceEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReduceEvent = {
    index: number;
    orderSequenceNumber: beet.bignum;
    priceInTicks: beet.bignum;
    baseLotsRemoved: beet.bignum;
    baseLotsRemaining: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const reduceEventBeet: beet.BeetArgsStruct<ReduceEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type TimeInForceEvent = {
    index: number;
    orderSequenceNumber: beet.bignum;
    lastValidSlot: beet.bignum;
    lastValidUnixTimestampInSeconds: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const timeInForceEventBeet: beet.BeetArgsStruct<TimeInForceEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * This type is used to derive the {@link PhoenixMarketEvent} type as well as the de/serializer.
 * However don't refer to it in your code but use the {@link PhoenixMarketEvent} type instead.
 *
 * @category userTypes
 * @category enums
 * @category generated
 * @private
 */
type PhoenixMarketEventRecord = {
    Uninitialized: void;
    Header: {
        fields: [AuditLogHeader];
    };
    Fill: {
        fields: [FillEvent];
    };
    Place: {
        fields: [PlaceEvent];
    };
    Reduce: {
        fields: [ReduceEvent];
    };
    Evict: {
        fields: [EvictEvent];
    };
    FillSummary: {
        fields: [FillSummaryEvent];
    };
    Fee: {
        fields: [FeeEvent];
    };
    TimeInForce: {
        fields: [TimeInForceEvent];
    };
    ExpiredOrder: {
        fields: [ExpiredOrderEvent];
    };
};
/**
 * Union type respresenting the PhoenixMarketEvent data enum defined in Rust.
 *
 * NOTE: that it includes a `__kind` property which allows to narrow types in
 * switch/if statements.
 * Additionally `isPhoenixMarketEvent*` type guards are exposed below to narrow to a specific variant.
 *
 * @category userTypes
 * @category enums
 * @category generated
 */
type PhoenixMarketEvent = beet.DataEnumKeyAsKind<PhoenixMarketEventRecord>;
declare const isPhoenixMarketEventUninitialized: (x: PhoenixMarketEvent) => x is {
    __kind: "Uninitialized";
} & Omit<void, "void"> & {
    __kind: "Uninitialized";
};
declare const isPhoenixMarketEventHeader: (x: PhoenixMarketEvent) => x is {
    __kind: "Header";
} & Omit<{
    fields: [AuditLogHeader];
}, "void"> & {
    __kind: "Header";
};
declare const isPhoenixMarketEventFill: (x: PhoenixMarketEvent) => x is {
    __kind: "Fill";
} & Omit<{
    fields: [FillEvent];
}, "void"> & {
    __kind: "Fill";
};
declare const isPhoenixMarketEventPlace: (x: PhoenixMarketEvent) => x is {
    __kind: "Place";
} & Omit<{
    fields: [PlaceEvent];
}, "void"> & {
    __kind: "Place";
};
declare const isPhoenixMarketEventReduce: (x: PhoenixMarketEvent) => x is {
    __kind: "Reduce";
} & Omit<{
    fields: [ReduceEvent];
}, "void"> & {
    __kind: "Reduce";
};
declare const isPhoenixMarketEventEvict: (x: PhoenixMarketEvent) => x is {
    __kind: "Evict";
} & Omit<{
    fields: [EvictEvent];
}, "void"> & {
    __kind: "Evict";
};
declare const isPhoenixMarketEventFillSummary: (x: PhoenixMarketEvent) => x is {
    __kind: "FillSummary";
} & Omit<{
    fields: [FillSummaryEvent];
}, "void"> & {
    __kind: "FillSummary";
};
declare const isPhoenixMarketEventFee: (x: PhoenixMarketEvent) => x is {
    __kind: "Fee";
} & Omit<{
    fields: [FeeEvent];
}, "void"> & {
    __kind: "Fee";
};
declare const isPhoenixMarketEventTimeInForce: (x: PhoenixMarketEvent) => x is {
    __kind: "TimeInForce";
} & Omit<{
    fields: [TimeInForceEvent];
}, "void"> & {
    __kind: "TimeInForce";
};
declare const isPhoenixMarketEventExpiredOrder: (x: PhoenixMarketEvent) => x is {
    __kind: "ExpiredOrder";
} & Omit<{
    fields: [ExpiredOrderEvent];
}, "void"> & {
    __kind: "ExpiredOrder";
};
/**
 * @category userTypes
 * @category generated
 */
declare const phoenixMarketEventBeet: beet.FixableBeet<PhoenixMarketEvent, PhoenixMarketEvent>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ReduceOrderParams = {
    baseParams: CancelOrderParams;
    size: beet.bignum;
};
/**
 * @category userTypes
 * @category generated
 */
declare const reduceOrderParamsBeet: beet.BeetArgsStruct<ReduceOrderParams>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type Seat = {
    discriminant: beet.bignum;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    approvalStatus: beet.bignum;
    padding: beet.bignum[];
};
/**
 * @category userTypes
 * @category generated
 */
declare const seatBeet: beet.BeetArgsStruct<Seat>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category enums
 * @category generated
 */
declare enum SeatApprovalStatus {
    NotApproved = 0,
    Approved = 1,
    Retired = 2
}
/**
 * @category userTypes
 * @category generated
 */
declare const seatApprovalStatusBeet: beet.FixedSizeBeet<SeatApprovalStatus, SeatApprovalStatus>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type WithdrawParams = {
    quoteLotsToWithdraw: beet.COption<beet.bignum>;
    baseLotsToWithdraw: beet.COption<beet.bignum>;
};
/**
 * @category userTypes
 * @category generated
 */
declare const withdrawParamsBeet: beet.FixableBeetArgsStruct<WithdrawParams>;

/**
 * Converts a beet.bignum to a number.
 *
 * @param n The number to convert
 */
declare function toNum(n: beet.bignum): number;
/**
 * Converts a number to a BN.
 *
 * @param n The number to convert
 */
declare function toBN(n: number | beet.bignum): BN;
/**
 * Converts a BN sort value to a number.
 *
 * Required because sort function must return a number.
 *
 * @param n The BN to convert
 */
declare function sign(n: BN): 0 | 1 | -1;

type OrderId = {
    priceInTicks: beet.bignum;
    orderSequenceNumber: beet.bignum;
};
type RestingOrder = {
    traderIndex: beet.bignum;
    numBaseLots: beet.bignum;
    lastValidSlot: beet.bignum;
    lastValidUnixTimestampInSeconds: beet.bignum;
};
type TraderState = {
    quoteLotsLocked: beet.bignum;
    quoteLotsFree: beet.bignum;
    baseLotsLocked: beet.bignum;
    baseLotsFree: beet.bignum;
    padding: beet.bignum[];
};
type LadderLevel = {
    priceInTicks: BN;
    sizeInBaseLots: BN;
};
type Ladder = {
    bids: Array<LadderLevel>;
    asks: Array<LadderLevel>;
};
type L3Order = {
    priceInTicks: BN;
    side: Side;
    sizeInBaseLots: BN;
    makerPubkey: string;
    orderSequenceNumber: BN;
    lastValidSlot: BN;
    lastValidUnixTimestampInSeconds: BN;
};
type L3UiOrder = {
    price: number;
    side: Side;
    size: number;
    makerPubkey: string;
    orderSequenceNumber: string;
    lastValidSlot: number;
    lastValidUnixTimestampInSeconds: number;
};
type L3Book = {
    bids: L3Order[];
    asks: L3Order[];
};
type L3UiBook = {
    bids: L3UiOrder[];
    asks: L3UiOrder[];
};
type UiLadderLevel = {
    price: number;
    quantity: number;
};
type UiLadder = {
    bids: Array<UiLadderLevel>;
    asks: Array<UiLadderLevel>;
};
interface MarketData {
    header: MarketHeader;
    baseLotsPerBaseUnit: number;
    quoteLotsPerBaseUnitPerTick: number;
    orderSequenceNumber: number;
    takerFeeBps: number;
    collectedQuoteLotFees: number;
    unclaimedQuoteLotFees: number;
    bids: Array<[OrderId, RestingOrder]>;
    asks: Array<[OrderId, RestingOrder]>;
    traders: Map<string, TraderState>;
    traderPubkeyToTraderIndex: Map<string, number>;
    traderIndexToTraderPubkey: Map<number, string>;
}
declare class MarketState {
    address: PublicKey;
    data: MarketData;
    constructor({ address, data }: {
        address: PublicKey;
        data: MarketData;
    });
    /**
     * Returns a `Market` for a given address, a data buffer, and a list of tokens to use for the market
     *
     * @param marketAddress The `PublicKey` of the market account
     * @param buffer The buffer holding the market account data
     * @param tokenList The list of tokens to use for the market
     */
    static load({ address, buffer, }: {
        address: PublicKey;
        buffer: Buffer;
    }): MarketState;
    /**
     * Returns a `Market` for a given address, a data buffer, and a list of tokens to use for the market
     *
     * @param connection The Solana `Connection` object
     * @param address The `PublicKey` of the market account
     * @param tokenList The list of tokens to use for the market (optional)
     */
    static loadFromAddress({ connection, address, tokenList, }: {
        connection: Connection;
        address: PublicKey;
        tokenList?: TokenConfig[];
    }): Promise<MarketState>;
    /**
     * Reloads market data from buffer
     *
     * @param buffer A data buffer with the serialized market data
     *
     * @returns The reloaded Market
     */
    reload(buffer: Buffer): MarketState;
    /**
     * Reloads market data from buffer (in place)
     *
     * @param connection The Solana `Connection` object
     *
     */
    reloadFromNetwork(connection: Connection): Promise<void>;
    getMarketSequenceNumber(): number;
    /**
     * Get a trader's base ATA for a given market
     *
     * @param trader The `PublicKey` of the trader account
     */
    getBaseAccountKey(trader: PublicKey): PublicKey;
    /**
     * Get a trader's quote ATA for a given market
     *
     * @param trader The `PublicKey` of the trader account
     */
    getQuoteAccountKey(trader: PublicKey): PublicKey;
    /**
     * Get the quote vault token account address for a given market
     */
    getQuoteVaultKey(): PublicKey;
    /**
     * Get the base vault token account address for a given market
     */
    getBaseVaultKey(): PublicKey;
    /**
     * Get a trader's seat account address
     *
     * @param trader The `PublicKey` of the trader account
     */
    getSeatAddress(trader: PublicKey): PublicKey;
    /**
     * Returns the ladder of bids and asks as JS numbers for given `MarketData`
     *
     * @param levels The number of book levels to return
     */
    getUiLadder(levels?: number, slot?: beet.bignum, unixTimestamp?: beet.bignum): UiLadder;
    /**
     * Returns an L2 ladder of bids and asks for given `MarketData`
     * @description Bids are ordered in descending order by price, and asks are ordered in ascending order by price
     *
     * @param marketData The `MarketData` to get the ladder from
     * @param slot The current slot
     * @param unixTimestamp The current Unix timestamp, in seconds
     * @param levels The number of book levels to return, -1 to return the entire book
     */
    getLadder(slot: beet.bignum, unixTimestamp: beet.bignum, levels?: number): Ladder;
    /**
     * Converts a ladder level from BN to JS number representation
     *
     * @param priceInTicks The price of the level in ticks
     * @param sizeInBaseLots The size of the level in base lots
     */
    levelToUiLevel(priceInTicks: number, sizeInBaseLots: number): UiLadderLevel;
    /**
     * Returns the expected amount out for a given swap order
     *
     * @param side The side of the order (Bid or Ask)
     * @param inAmount The amount of the input token
     * @param slot The current slot
     * @param unixTimestamp The current unix timestamp, in seconds
     */
    getExpectedOutAmount({ side, inAmount, slot, unixTimestamp, }: {
        side: Side;
        inAmount: number;
        slot: beet.bignum;
        unixTimestamp: beet.bignum;
    }): number;
    /**
     * Returns the required amount in for a desired amount of units out
     *
     * @param side The side of the order (Bid or Ask)
     * @param outAmount The amount of the desired output token
     * @param slot The current slot
     * @param unixTimestamp The current unix timestamp, in seconds
     */
    getRequiredInAmount({ side, outAmount, slot, unixTimestamp, }: {
        side: Side;
        outAmount: number;
        slot: beet.bignum;
        unixTimestamp: beet.bignum;
    }): number;
    getPriceDecimalPlaces(): number;
    /**
     * Given a price in quote units per raw base unit, returns the price in ticks.
     *
     * Example: With a market tick size of 0.01, and a price of 1.23 quote units per raw base unit, the price in ticks is 123
     *
     * @param price The price to convert
     */
    floatPriceToTicks(price: number): number;
    /**
     * Given a price in ticks, returns the price in quote units per raw base unit.
     *
     * Example: With a market tick size of 0.01, and a price of 123 ticks, the price in quote units per raw base unit is 1.23
     *
     * @param ticks The price in ticks to convert
     */
    ticksToFloatPrice(ticks: number): number;
    /**
     * Given a number of raw base units, returns the equivalent number of base lots (rounded down).
     *
     * @param rawBaseUnits The amount of raw base units to convert
     */
    rawBaseUnitsToBaseLotsRoundedDown(rawBaseUnits: number): number;
    /**
     * Given a number of raw base units, returns the equivalent number of base lots (rounded up).
     *
     * @param rawBaseUnits The amount of raw base units to convert
     */
    rawBaseUnitsToBaseLotsRoundedUp(rawBaseUnits: number): number;
    /**
     * Given a number of base atoms, returns the equivalent number of base lots.
     *
     * @param baseAtoms The amount of base atoms to convert
     */
    baseAtomsToBaseLots(baseAtoms: number): number;
    /**
     * Given a number of base lots, returns the equivalent number of base atoms.
     *
     * @param baseLots The amount of base lots to convert
     */
    baseLotsToBaseAtoms(baseLots: number): number;
    /**
     * Given a number of base lots, returns the equivalent number of raw base units.
     *
     * @param baseLots The amount of base lots to convert
     */
    baseLotsToRawBaseUnits(baseLots: number): number;
    /**
     * Given a number of quote units, returns the equivalent number of quote lots.
     *
     * @param quoteUnits The amount of quote units to convert
     */
    quoteUnitsToQuoteLots(quoteUnits: number): number;
    /**
     * Given a number of quote atoms, returns the equivalent number of quote lots.
     *
     * @param quoteAtoms The amount of quote atoms to convert
     */
    quoteAtomsToQuoteLots(quoteAtoms: number): number;
    /**
     * Given a number of quote lots, returns the equivalent number of quote atoms.
     *
     * @param quoteLots The amount of quote lots to convert
     */
    quoteLotsToQuoteAtoms(quoteLots: number): number;
    /**
     * Given a number of quote lots, returns the equivalent number of raw quote units.
     *
     * @param quoteLots The amount of quote lots to convert
     */
    quoteLotsToQuoteUnits(quoteLots: number): number;
    /**
     * Given a number of base atoms, returns the equivalent number of raw base units.
     *
     * @param baseAtoms The amount of base atoms to convert
     */
    baseAtomsToRawBaseUnits(baseAtoms: number): number;
    /**
     * Given a number of quote atoms, returns the equivalent number of quote units.
     *
     * @param quoteAtoms The amount of quote atoms to convert
     */
    quoteAtomsToQuoteUnits(quoteAtoms: number): number;
    /**
     * Instruction builders
     **/
    /**
     * Creates a _CancelAllOrders_ instruction.
     *
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelAllOrdersInstruction(trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelAllOrdersWithFreeFunds_ instruction.
     *
     * @param trader Trader public key (defaults to client's wallet public key)
     * @category Instructions
     */
    createCancelAllOrdersWithFreeFundsInstruction(trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelMultipleOrdersById_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     * @category CancelMultipleOrdersById
     */
    createCancelMultipleOrdersByIdInstruction(args: CancelMultipleOrdersByIdInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelMultipleOrdersByIdWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelMultipleOrdersByIdWithFreeFundsInstruction(args: CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelUpTo_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelUpToInstruction(args: CancelUpToInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelUpToWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelUpToWithFreeFundsInstruction(args: CancelUpToWithFreeFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _DepositFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createDepositFundsInstruction(args: DepositFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceLimitOrder_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceLimitOrderInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceLimitOrderWithFreeFunds_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceLimitOrderWithFreeFundsInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceMultiplePostOnlyOrders_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceMultiplePostOnlyOrdersInstruction(args: PlaceMultiplePostOnlyOrdersInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceMultiplePostOnlyOrdersInstructionWithFreeFunds(args: PlaceMultiplePostOnlyOrdersInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _ReduceOrder_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createReduceOrderInstruction(args: ReduceOrderInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _ReduceOrderWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createReduceOrderWithFreeFundsInstruction(args: ReduceOrderWithFreeFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _RequestSeat_ instruction.
     *
     * @param payer Payer public key
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createRequestSeatInstruction(payer: PublicKey, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _Swap_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createSwapInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _SwapWithFreeFunds_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createSwapWithFreeFundsInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _WithdrawFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createWithdrawFundsInstruction(args: WithdrawFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    getSwapOrderPacket({ side, inAmount, slippage, selfTradeBehavior, matchLimit, clientOrderId, useOnlyDepositedFunds, lastValidSlot, lastValidUnixTimestampInSeconds, }: {
        side: Side;
        inAmount: number;
        slippage?: number;
        selfTradeBehavior?: SelfTradeBehavior;
        matchLimit?: number;
        clientOrderId?: number;
        useOnlyDepositedFunds?: boolean;
        lastValidSlot?: number;
        lastValidUnixTimestampInSeconds?: number;
    }): OrderPacket;
    /**
     * Returns an instruction to place a limit order on a market, using a LimitOrderPacketTemplate, which takes in human-friendly units
     * @param trader The trader's address
     * @param limitOrderTemplate The order packet template to place
     * @returns
     */
    getLimitOrderInstructionfromTemplate(trader: PublicKey, limitOrderTemplate: LimitOrderTemplate): TransactionInstruction;
    /**
     * Returns an instruction to place a post only on a market, using a PostOnlyOrderPacketTemplate, which takes in human-friendly units.
     * @param trader The trader's address
     * @param postOnlyOrderTemplate The order packet template to place
     * @returns
     */
    getPostOnlyOrderInstructionfromTemplate(trader: PublicKey, postOnlyOrderTemplate: PostOnlyOrderTemplate): TransactionInstruction;
    /**
     * Returns an instruction to place an immediate or cancel on a market, using a ImmediateOrCancelPacketTemplate, which takes in human-friendly units.
     * @param trader The trader's address
     * @param immediateOrCancelOrderTemplate The order packet template to place
     * @returns
     */
    getImmediateOrCancelOrderInstructionfromTemplate(trader: PublicKey, immediateOrCancelOrderTemplate: ImmediateOrCancelOrderTemplate): TransactionInstruction;
}

declare const DEFAULT_L2_LADDER_DEPTH = 10;
declare const DEFAULT_L3_BOOK_DEPTH = 20;
declare const DEFAULT_MATCH_LIMIT = 2048;
declare const DEFAULT_SLIPPAGE_PERCENT = 0.005;
/**
 * Find the trader's seat account on Phoenix market.
 * If the trader does not have a seat account, the PDA seat pubkey will still be returned.
 * In that case, the seat account will need to be initialized with the claim seat instruction.
 * @param marketPubkey The market's address
 * @param trader The trader's address
 */
declare function getSeatAddress(market: PublicKey, trader: PublicKey): PublicKey;
/**
 * Deserializes market data from a given buffer and returns a `MarketData` object
 *
 * @param data The data buffer to deserialize
 */
declare function deserializeMarketData(data: Buffer): MarketData;
/**
 * Takes a raw order ID and returns a displayable order sequence number
 *
 * On the raw order book, sequence numbers are stored as unsigned 64-bit integers,
 * with bits inverted for bids and left as-is for asks. This function converts
 * the raw order ID to a signed 64-bit integer, and then converts it to a
 * displayable order sequence number.
 *
 * @param orderId
 */
declare function getUiOrderSequenceNumber(orderId: OrderId): BN;
/**
 * Returns the order sequence number used to build a cancel order instruction from an L3 order
 * @param order
 */
declare function getOrderSequenceNumberFromL3Order(order: L3Order): BN;
/**
 * Returns the cancel order params used to build a cancel order instruction from an L3 order
 * @param order
 */
declare function getCancelOrderParamsFromL3Order(order: L3Order): CancelOrderParams;
/**
 * Returns an L2 ladder of bids and asks for given `MarketData`
 * @description Bids are ordered in descending order by price, and asks are ordered in ascending order by price
 *
 * @param market The `Market` to get the ladder from
 * @param slot The current slot
 * @param unixTimestamp The current Unix timestamp, in seconds
 * @param levels The number of book levels to return, -1 to return the entire book
 */
declare function getMarketLadder(market: MarketState, slot: beet.bignum, unixTimestamp: beet.bignum, levels?: number): Ladder;
/**
 * Converts a ladder level from BN to JS number representation
 *
 * @param marketData The `MarketData` the ladder was taken from
 * @param priceInTicks The price of the level in ticks
 * @param sizeInBaseLots The size of the level in base lots
 * @param quoteAtomsPerQuoteUnit The number of quote atoms per quote unit
 */
declare function levelToUiLevel(market: MarketState, priceInTicks: number, sizeInBaseLots: number): UiLadderLevel;
/**
 * Returns the ladder of bids and asks as JS numbers for given `MarketData`
 *
 * @param maata The `Market` to get the ladder from
 * @param levels The number of book levels to return
 */
declare function getMarketUiLadder(market: MarketState, levels?: number, slot?: beet.bignum, unixTimestamp?: beet.bignum): UiLadder;
/**
 * Pretty prints the market's ladder as a colored orderbook
 *
 * @param uiLadder The ladder (represented by JS numbers) to print
 */
declare function printUiLadder(uiLadder: UiLadder): void;
/**
 * Returns the L3 book of bids and asks for a given `MarketData`.
 * @description Bids are ordered in descending order by price, and asks are ordered in ascending order by price
 *
 * @param marketData The `MarketData` to get the ladder from
 * @param slot The current slot
 * @param unixTimestamp The current Unix timestamp, in seconds
 * @param ordersPerSide The max number of orders to return per side. -1 to return the entire book
 */
declare function getMarketL3Book(marketData: MarketData, slot: beet.bignum, unixTimestamp: beet.bignum, ordersPerSide?: number): L3Book;
/**
 * Returns the L3 book of bids and asks as JS numbers
 *
 * @param marketData The `MarketData` to get the ladder from
 * @param levels The number of book levels to return
 */
declare function getMarketL3UiBook(marketData: MarketData, ordersPerSide?: number, slot?: beet.bignum, unixTimestamp?: beet.bignum): L3UiBook;
/**
 * Returns a Phoenix swap transaction
 *
 * @param market The market object
 * @param trader The `PublicKey` of the trader
 * @param side The side of the order to place (Bid, Ask)
 * @param inAmount The amount (in whole tokens) of the input token to swap
 * @param slippage The slippage tolerance (optional, default 0.5%)
 * @param clientOrderId The client order ID (optional)
 * @param idempotent If set to true, the transaction will idempotently create both mint accounts (optional, default false)
 */
declare function getMarketSwapTransaction({ market, trader, side, inAmount, slippage, clientOrderId, idempotent, }: {
    market: MarketState;
    trader: PublicKey;
    side: Side;
    inAmount: number;
    slippage?: number;
    clientOrderId?: number;
    idempotent?: boolean;
}): Transaction;
/**
 * Given a side and an amount in, returns the expected amount out.
 *
 * @param uiLadder The uiLadder for the market. Note that prices in the uiLadder are in quote units per raw base unit (units of USDC per unit of SOL for the SOL/USDC market).
 * @param side The side of the order
 * @param takerFeeBps The taker fee in bps
 * @param inAmount The amount of the input token. Amounts are in quote units for bids and raw base units for asks.
 *
 */
declare function getExpectedOutAmountRouter({ uiLadder, side, takerFeeBps, inAmount, }: {
    uiLadder: UiLadder;
    side: Side;
    takerFeeBps: number;
    inAmount: number;
}): number;
/**
 * Given a side and a desired amount out, returns the amount in that would be required to get the desired amount out.
 *
 * @param uiLadder The uiLadder for the market. Note that prices in the uiLadder are in quote units per raw base unit (units of USDC per unit of SOL for the SOL/USDC market).
 * @param side The side of the order
 * @param takerFeeBps The taker fee in bps
 * @param outAmount The amount of the output token. Output amounts are in raw base units for bids and quote units for asks.
 *
 */
declare function getRequiredInAmountRouter({ uiLadder, side, takerFeeBps, outAmount, }: {
    uiLadder: UiLadder;
    side: Side;
    takerFeeBps: number;
    outAmount: number;
}): number;
/**
 * Given an amount of quote units to spend, return the number of raw base units that will be received.
 * This function represents a Buy order where the caller knows the amount of quote tokens they are willing to spend and wants to know how many raw base units they can receive.
 *
 * @param uiLadder The uiLadder for the market. Note that prices in the uiLadder are in quote units per raw base unit (units of USDC per unit of SOL for the SOL/USDC market).
 * @param takerFeeBps The taker fee in bps
 * @param quoteUnitsIn The amount of quote units to spend to buy the base token
 *
 */
declare function getRawBaseUnitsOutFromQuoteUnitsIn({ uiLadder, takerFeeBps, quoteUnitsIn, }: {
    uiLadder: UiLadder;
    takerFeeBps: number;
    quoteUnitsIn: number;
}): number;
/**
 * Given an amount of raw base units to sell, return the number of quote units that will be received.
 * This function represents a Sell order where the caller knows the amount of raw base units they are willing to sell and wants to know how many raw base units they can receive.
 *
 * @param uiLadder The uiLadder for the market. Note that prices in the uiLadder are in quote units per raw base unit (units of USDC per unit of SOL for the SOL/USDC market).
 * @param takerFeeBps The taker fee in bps
 * @param rawBaseUnitsIn The amount of raw base units to sell
 *
 */
declare function getQuoteUnitsOutFromRawBaseUnitsIn({ uiLadder, takerFeeBps, rawBaseUnitsIn, }: {
    uiLadder: UiLadder;
    takerFeeBps: number;
    rawBaseUnitsIn: number;
}): number;
/**
 * Given a desired amount of quote units to obtain, return the number of raw base units that need to be sold to get that amount of quote units.
 * This function represents a Sell order where the caller knows the amount of quote units they want to obtain and wants to know how many raw base units they need to sell in order to obtain that amount of quote units.
 *
 * @param uiLadder The uiLadder for the market. Note that prices in the uiLadder are in quote units per raw base unit (units of USDC per unit of SOL for the SOL/USDC market).
 * @param takerFeeBps The taker fee in bps
 * @param quoteUnitsOut The amount of quote units to obtain
 *
 */
declare function getRawBaseUnitsInFromQuoteUnitsOut({ uiLadder, takerFeeBps, quoteUnitsOut, }: {
    uiLadder: UiLadder;
    takerFeeBps: number;
    quoteUnitsOut: number;
}): number;
/**
 * Given a desired amount of raw base units to obtain, return the number of quote units that need to be spent to get that amount of raw base units.
 * This function represents a Buy order where the caller knows the amount of raw base units they want to obtain but does not know how many quote units they need to spend in order to obtain that amount of raw base units.
 *
 * @param uiLadder The uiLadder for the market. Note that prices in the uiLadder are in quote units per raw base unit (units of USDC per unit of SOL for the SOL/USDC market).
 * @param takerFeeBps The taker fee in bps
 * @param rawBaseUnitsOut The amount of raw base units to obtain
 *
 */
declare function getQuoteUnitsInFromRawBaseUnitsOut({ uiLadder, takerFeeBps, rawBaseUnitsOut, }: {
    uiLadder: UiLadder;
    takerFeeBps: number;
    rawBaseUnitsOut: number;
}): number;
/**
 * Given a budget of quote units in, return the number of raw base units that can be matched.
 *
 * @param sideOfBook The side of the book to match against. If the order is a buy order, then the sideOfBook input is the asks array. If the order is a sell order, then the sideOfBook input is the bids array.
 * @param quoteAmountBudget The amount of quote units to match with.
 *
 */
declare function getBaseAmountFromQuoteAmountBudgetAndBook({ sideOfBook, quoteAmountBudget, }: {
    sideOfBook: UiLadderLevel[];
    quoteAmountBudget: number;
}): number;
/**
 * Given a budget of raw base units in, return the number of quote units that can be matched.
 *
 * @param sideOfBook The side of the book to match against. If the order is a buy order, then the sideOfBook input is the asks array. If the order is a sell order, then the sideOfBook input is the bids array.
 * @param baseAmountBudget The amount of raw base units to match with.
 *
 */
declare function getQuoteAmountFromBaseAmountBudgetAndBook({ sideOfBook, baseAmountBudget, }: {
    sideOfBook: UiLadderLevel[];
    baseAmountBudget: number;
}): number;
/**
 * Returns instructions for setting up a new maker on a market. Includes:
 * - create associated token accounts for base and quote tokens if needed
 * - create a claim seat instruction if needed, including performing a seat eviction if the market's trader state is full.
 * @param connection An instance of the Connection class
 * @param market The market object
 * @param trader The trader's address
 * @returns
 */
declare function getMakerSetupInstructionsForMarket(connection: Connection, market: MarketState, trader: PublicKey): Promise<TransactionInstruction[]>;
/**
 * Return all instructions necessary to place a limit order on a market, including
 * - checking for and creating ATAs, if they do not exist
 * - checking for and claiming a seat, if trader does not have a seat on the market
 * - instruction for placing the limit order itself
 * Useful if unknown whether trader has the correct ATAs and seat initialized
 * @param connection An instance of the Connection class
 * @param market A market object
 * @param trader The trader's address
 * @param orderPacket The order packet to place
 * @returns
 */
declare function getLimitOrderNewMakerIxs(connection: Connection, market: MarketState, trader: PublicKey, orderPacket: OrderPacket): Promise<TransactionInstruction[]>;
/**
 * Returns instructions for claiming a seat on a market and placing a limit order
 * Useful if the caller is uncertain whether the trader has been evicted from the market, but knows the trader has ATAs
 * @param connection An instance of the Connection class
 * @param market The market object
 * @param trader The trader's address
 * @param orderPacket The order packet to place
 * @returns
 */
declare function getLimitOrderUnknownSeatIxs(connection: Connection, market: MarketState, trader: PublicKey, orderPacket: OrderPacket): Promise<TransactionInstruction[]>;

type Cluster = "mainnet-beta" | "devnet" | "localhost";
declare function getClusterFromConnection(connection: Connection): Promise<Cluster>;
declare function deserializeClockData(data: Buffer): ClockData;
type ClockData = {
    slot: beet.bignum;
    epochStartTime: beet.bignum;
    epoch: beet.bignum;
    leaderScheduleEpoch: beet.bignum;
    unixTimestamp: beet.bignum;
};
declare const clockBeet: beet.BeetArgsStruct<ClockData>;

declare function getCreateTokenAccountInstructions(connection: Connection, trader: PublicKey, payer: PublicKey, tokenMintAddress: PublicKey): Promise<TransactionInstruction[]>;

/**
 * Get market account data and clock data with zstd compression
 * @param connection The web3 connection object
 * @param marketKeys The market addresses
 * @param commitment The commitment level
 * @returns
 */
declare const getConfirmedMarketsAndClockAccounts: (connection: Connection, marketKeys: PublicKey[], commitment?: Commitment) => Promise<Buffer[]>;
/**
 * Get market account data and clock data with zstd compression
 * @param connection The web3 connection object
 * @param marketKeys The market addresses
 * @param commitment The commitment level
 * @returns
 */
declare const getConfirmedMarketsAndClockAccountsZstd: (connection: Connection, marketKeys: PublicKey[], commitment?: Commitment) => Promise<Buffer[]>;
/**
 * Get market account data with zstd compression
 * @param connection The web3 connection object
 * @param marketKey The market address
 * @param commitment The commitment level
 * @returns
 */
declare const getConfirmedMarketAccountZstd: (connection: Connection, marketKey: PublicKey, commitment?: Commitment) => Promise<Buffer>;

/**
 * Deserializes seat manager data from a given buffer and returns a SeatManagerData object
 *
 * @param data The data buffer to deserialize
 */
declare function deserializeSeatManagerData(data: Buffer): SeatManagerData;
type SeatManagerData = {
    market: PublicKey;
    authority: PublicKey;
    successor: PublicKey;
    numMakers: beet.bignum;
    _headerPadding: beet.bignum[];
    designatedMarketMaker: PublicKey[];
    _dmmPadding: beet.bignum[];
};
declare const seatManagerBeet: beet.BeetArgsStruct<SeatManagerData>;
/**
 * Find the seat manager's address
 * @param marketPubkey The market's address
 */
declare function getSeatManagerAddress(market: PublicKey): PublicKey;
/**
 * Get the seat deposit collector's address
 * @param marketPubkey The market's address
 */
declare function getSeatDepositCollectorAddress(market: PublicKey): PublicKey;
/**
 * Returns an instruction to claim a seat on a market, via the Phoenix Seat Manager
 *
 * @param market The market's address
 * @param trader The trader's address
 */
declare function getClaimSeatIx(market: PublicKey, trader: PublicKey): TransactionInstruction;
/**
 * Returns an instruction to evict a seat on a market, via the Phoenix Seat Manager
 * Evict seat is only allowed if the trader state is full for a given market, unless performed by the seat manager authority
 *
 * @param marketState The market object
 * @param trader The address of the trader to be evicted
 * @param signer The address of the signer of the transaction. Does not need to be the trader if the market's trader state is full.
 * @param baseTokenAccountBackup The to-be-evicted trader's base token account backup, in the event the associated token account of the trader is no longer owned by the trader
 * @param quoteTokenAccountBackup The to-be-evicted trader's quote token account backup, in the event the associated token account of the trader is no longer owned by the trader
 */
declare function getEvictSeatIx(marketState: MarketState, trader: PublicKey, signer: PublicKey, baseTokenAccountBackup?: PublicKey, quoteTokenAccountBackup?: PublicKey): TransactionInstruction;
/**
 * Checks if the given trader has a seat on the given market
 * If not, return claim seat instructions
 * @param connection An instance of the Connection class
 * @param marketState The market object
 * @param trader The trader's address
 */
declare function confirmOrCreateClaimSeatIxs(connection: Connection, marketState: MarketState, trader: PublicKey): Promise<TransactionInstruction[]>;
/**
 * Checks if the given trader has a seat on the given market
 * If not, return claim seat instructions
 * @param connection An instance of the Connection class
 * @param marketState The market object
 * @param trader The trader's address
 */
declare function createClaimSeatInstructions(connection: Connection, marketState: MarketState, trader: PublicKey): Promise<TransactionInstruction[]>;
/**
 * Find a trader to evict from the given market.
 * If the market's trader state is not at capacity or if every trader has locked base or quote lots, then return undefined.
 * If the seats are full, this function will return the first trader that has no base or quote lots locked.
 * @param connection An instance of the Connection class
 * @param marketState The market object
 * @returns
 */
declare function findTraderToEvict(connection: Connection, marketState: MarketState): Promise<PublicKey | void>;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelAllOrders
 * @category generated
 */
declare const CancelAllOrdersStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelAllOrders_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category CancelAllOrders
 * @category generated
 */
type CancelAllOrdersInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const cancelAllOrdersInstructionDiscriminator = 6;
/**
 * Creates a _CancelAllOrders_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category CancelAllOrders
 * @category generated
 */
declare function createCancelAllOrdersInstruction(accounts: CancelAllOrdersInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelAllOrdersWithFreeFunds
 * @category generated
 */
declare const CancelAllOrdersWithFreeFundsStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelAllOrdersWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @category Instructions
 * @category CancelAllOrdersWithFreeFunds
 * @category generated
 */
type CancelAllOrdersWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const cancelAllOrdersWithFreeFundsInstructionDiscriminator = 7;
/**
 * Creates a _CancelAllOrdersWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category CancelAllOrdersWithFreeFunds
 * @category generated
 */
declare function createCancelAllOrdersWithFreeFundsInstruction(accounts: CancelAllOrdersWithFreeFundsInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
type CancelMultipleOrdersByIdInstructionArgs = {
    params: CancelMultipleOrdersByIdParams;
};
/**
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
declare const CancelMultipleOrdersByIdStruct: beet.FixableBeetArgsStruct<CancelMultipleOrdersByIdInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelMultipleOrdersById_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
type CancelMultipleOrdersByIdInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const cancelMultipleOrdersByIdInstructionDiscriminator = 10;
/**
 * Creates a _CancelMultipleOrdersById_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelMultipleOrdersById
 * @category generated
 */
declare function createCancelMultipleOrdersByIdInstruction(accounts: CancelMultipleOrdersByIdInstructionAccounts, args: CancelMultipleOrdersByIdInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
type CancelMultipleOrdersByIdWithFreeFundsInstructionArgs = {
    params: CancelMultipleOrdersByIdParams;
};
/**
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
declare const CancelMultipleOrdersByIdWithFreeFundsStruct: beet.FixableBeetArgsStruct<CancelMultipleOrdersByIdWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelMultipleOrdersByIdWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
type CancelMultipleOrdersByIdWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const cancelMultipleOrdersByIdWithFreeFundsInstructionDiscriminator = 11;
/**
 * Creates a _CancelMultipleOrdersByIdWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelMultipleOrdersByIdWithFreeFunds
 * @category generated
 */
declare function createCancelMultipleOrdersByIdWithFreeFundsInstruction(accounts: CancelMultipleOrdersByIdWithFreeFundsInstructionAccounts, args: CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
type CancelUpToInstructionArgs = {
    params: CancelUpToParams;
};
/**
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
declare const CancelUpToStruct: beet.FixableBeetArgsStruct<CancelUpToInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelUpTo_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
type CancelUpToInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const cancelUpToInstructionDiscriminator = 8;
/**
 * Creates a _CancelUpTo_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelUpTo
 * @category generated
 */
declare function createCancelUpToInstruction(accounts: CancelUpToInstructionAccounts, args: CancelUpToInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
type CancelUpToWithFreeFundsInstructionArgs = {
    params: CancelUpToParams;
};
/**
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
declare const CancelUpToWithFreeFundsStruct: beet.FixableBeetArgsStruct<CancelUpToWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _CancelUpToWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
type CancelUpToWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const cancelUpToWithFreeFundsInstructionDiscriminator = 9;
/**
 * Creates a _CancelUpToWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CancelUpToWithFreeFunds
 * @category generated
 */
declare function createCancelUpToWithFreeFundsInstruction(accounts: CancelUpToWithFreeFundsInstructionAccounts, args: CancelUpToWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
type DepositFundsInstructionArgs = {
    depositFundsParams: DepositParams;
};
/**
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
declare const DepositFundsStruct: beet.BeetArgsStruct<DepositFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _DepositFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
type DepositFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const depositFundsInstructionDiscriminator = 13;
/**
 * Creates a _DepositFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category DepositFunds
 * @category generated
 */
declare function createDepositFundsInstruction(accounts: DepositFundsInstructionAccounts, args: DepositFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Log
 * @category generated
 */
declare const LogStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _Log_ instruction
 *
 * @property [**signer**] logAuthority Log authority
 * @category Instructions
 * @category Log
 * @category generated
 */
type LogInstructionAccounts = {
    logAuthority: web3.PublicKey;
};
declare const logInstructionDiscriminator = 15;
/**
 * Creates a _Log_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category Log
 * @category generated
 */
declare function createLogInstruction(accounts: LogInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
type PlaceLimitOrderInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
declare const PlaceLimitOrderStruct: beet.FixableBeetArgsStruct<PlaceLimitOrderInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceLimitOrder_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
type PlaceLimitOrderInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const placeLimitOrderInstructionDiscriminator = 2;
/**
 * Creates a _PlaceLimitOrder_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceLimitOrder
 * @category generated
 */
declare function createPlaceLimitOrderInstruction(accounts: PlaceLimitOrderInstructionAccounts, args: PlaceLimitOrderInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
type PlaceLimitOrderWithFreeFundsInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
declare const PlaceLimitOrderWithFreeFundsStruct: beet.FixableBeetArgsStruct<PlaceLimitOrderWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceLimitOrderWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
type PlaceLimitOrderWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
};
declare const placeLimitOrderWithFreeFundsInstructionDiscriminator = 3;
/**
 * Creates a _PlaceLimitOrderWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceLimitOrderWithFreeFunds
 * @category generated
 */
declare function createPlaceLimitOrderWithFreeFundsInstruction(accounts: PlaceLimitOrderWithFreeFundsInstructionAccounts, args: PlaceLimitOrderWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersInstructionArgs = {
    multipleOrderPacket: MultipleOrderPacket;
};
/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
declare const PlaceMultiplePostOnlyOrdersStruct: beet.FixableBeetArgsStruct<PlaceMultiplePostOnlyOrdersInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceMultiplePostOnlyOrders_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const placeMultiplePostOnlyOrdersInstructionDiscriminator = 16;
/**
 * Creates a _PlaceMultiplePostOnlyOrders_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrders
 * @category generated
 */
declare function createPlaceMultiplePostOnlyOrdersInstruction(accounts: PlaceMultiplePostOnlyOrdersInstructionAccounts, args: PlaceMultiplePostOnlyOrdersInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs = {
    multipleOrderPacket: MultipleOrderPacket;
};
/**
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
declare const PlaceMultiplePostOnlyOrdersWithFreeFundsStruct: beet.FixableBeetArgsStruct<PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
type PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
};
declare const placeMultiplePostOnlyOrdersWithFreeFundsInstructionDiscriminator = 17;
/**
 * Creates a _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category PlaceMultiplePostOnlyOrdersWithFreeFunds
 * @category generated
 */
declare function createPlaceMultiplePostOnlyOrdersWithFreeFundsInstruction(accounts: PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionAccounts, args: PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
type ReduceOrderInstructionArgs = {
    params: ReduceOrderParams;
};
/**
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
declare const ReduceOrderStruct: beet.BeetArgsStruct<ReduceOrderInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _ReduceOrder_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
type ReduceOrderInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const reduceOrderInstructionDiscriminator = 4;
/**
 * Creates a _ReduceOrder_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category ReduceOrder
 * @category generated
 */
declare function createReduceOrderInstruction(accounts: ReduceOrderInstructionAccounts, args: ReduceOrderInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
type ReduceOrderWithFreeFundsInstructionArgs = {
    params: ReduceOrderParams;
};
/**
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
declare const ReduceOrderWithFreeFundsStruct: beet.BeetArgsStruct<ReduceOrderWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _ReduceOrderWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [_writable_, **signer**] trader
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
type ReduceOrderWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
};
declare const reduceOrderWithFreeFundsInstructionDiscriminator = 5;
/**
 * Creates a _ReduceOrderWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category ReduceOrderWithFreeFunds
 * @category generated
 */
declare function createReduceOrderWithFreeFundsInstruction(accounts: ReduceOrderWithFreeFundsInstructionAccounts, args: ReduceOrderWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category RequestSeat
 * @category generated
 */
declare const RequestSeatStruct: beet.BeetArgsStruct<{
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _RequestSeat_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [_writable_, **signer**] payer
 * @property [_writable_] seat
 * @category Instructions
 * @category RequestSeat
 * @category generated
 */
type RequestSeatInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    payer: web3.PublicKey;
    seat: web3.PublicKey;
    systemProgram?: web3.PublicKey;
};
declare const requestSeatInstructionDiscriminator = 14;
/**
 * Creates a _RequestSeat_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @category Instructions
 * @category RequestSeat
 * @category generated
 */
declare function createRequestSeatInstruction(accounts: RequestSeatInstructionAccounts, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category Swap
 * @category generated
 */
type SwapInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category Swap
 * @category generated
 */
declare const SwapStruct: beet.FixableBeetArgsStruct<SwapInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _Swap_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category Swap
 * @category generated
 */
type SwapInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const swapInstructionDiscriminator = 0;
/**
 * Creates a _Swap_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category Swap
 * @category generated
 */
declare function createSwapInstruction(accounts: SwapInstructionAccounts, args: SwapInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
type SwapWithFreeFundsInstructionArgs = {
    orderPacket: OrderPacket;
};
/**
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
declare const SwapWithFreeFundsStruct: beet.FixableBeetArgsStruct<SwapWithFreeFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _SwapWithFreeFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [] seat
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
type SwapWithFreeFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    seat: web3.PublicKey;
};
declare const swapWithFreeFundsInstructionDiscriminator = 1;
/**
 * Creates a _SwapWithFreeFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category SwapWithFreeFunds
 * @category generated
 */
declare function createSwapWithFreeFundsInstruction(accounts: SwapWithFreeFundsInstructionAccounts, args: SwapWithFreeFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

/**
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
type WithdrawFundsInstructionArgs = {
    withdrawFundsParams: WithdrawParams;
};
/**
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
declare const WithdrawFundsStruct: beet.FixableBeetArgsStruct<WithdrawFundsInstructionArgs & {
    instructionDiscriminator: number;
}>;
/**
 * Accounts required by the _WithdrawFunds_ instruction
 *
 * @property [] phoenixProgram Phoenix program
 * @property [] logAuthority Phoenix log authority
 * @property [_writable_] market This account holds the market state
 * @property [**signer**] trader
 * @property [_writable_] baseAccount Trader base token account
 * @property [_writable_] quoteAccount Trader quote token account
 * @property [_writable_] baseVault Base vault PDA, seeds are [b'vault', market_address, base_mint_address]
 * @property [_writable_] quoteVault Quote vault PDA, seeds are [b'vault', market_address, quote_mint_address]
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
type WithdrawFundsInstructionAccounts = {
    phoenixProgram: web3.PublicKey;
    logAuthority: web3.PublicKey;
    market: web3.PublicKey;
    trader: web3.PublicKey;
    baseAccount: web3.PublicKey;
    quoteAccount: web3.PublicKey;
    baseVault: web3.PublicKey;
    quoteVault: web3.PublicKey;
    tokenProgram?: web3.PublicKey;
};
declare const withdrawFundsInstructionDiscriminator = 12;
/**
 * Creates a _WithdrawFunds_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category WithdrawFunds
 * @category generated
 */
declare function createWithdrawFundsInstruction(accounts: WithdrawFundsInstructionAccounts, args: WithdrawFundsInstructionArgs, programId?: web3.PublicKey): web3.TransactionInstruction;

type PhoenixTransaction = {
    instructions: Array<PhoenixEventsFromInstruction>;
    signature?: TransactionSignature;
    txReceived: boolean;
    txFailed: boolean;
};
type PhoenixEventsFromInstruction = {
    header: AuditLogHeader;
    events: Array<PhoenixMarketEvent>;
};
type PhoenixEvents = {
    events: PhoenixMarketEvent[];
};
declare const phoenixEventsBeet: beet.FixableBeetArgsStruct<PhoenixEvents>;
declare function decodePhoenixEvents(data: Uint8Array): PhoenixMarketEvent[];
declare function readPublicKey(reader: BinaryReader): PublicKey;
declare function getPhoenixEventsFromLogData(data: Uint8Array): PhoenixEventsFromInstruction;
/**
 * Returns a list of Phoenix events for a given transaction object
 *
 * @param txData The transaction object returned by `getParsedTransaction` of type `ParsedTransactionWithMeta`
 */
declare function getPhoenixEventsFromTransactionData(txData: ParsedTransactionWithMeta): PhoenixTransaction;
/**
 * Returns a list of Phoenix events for a given transaction signature
 *
 * @param connection The Solana `Connection` object
 * @param signature The signature of the transaction to fetch
 */
declare function getPhoenixEventsFromTransactionSignature(connection: Connection, signature: string): Promise<PhoenixTransaction>;
/**
 * Returns a list of Phoenix events for a given transaction signature
 *
 * @param connection The Solana `Connection` object
 * @param signature The signature of the transaction to fetch
 * @deprecated The method is deprecated. Please use `getPhoenixEventsFromTransactionSignature` instead
 */
declare function getEventsFromTransaction(connection: Connection, signature: TransactionSignature): Promise<PhoenixTransaction>;

declare class MarketMetadata {
    address: PublicKey;
    marketSizeParams: MarketSizeParams;
    baseParams: TokenParams;
    baseLotSize: number;
    quoteParams: TokenParams;
    quoteLotSize: number;
    tickSizeInQuoteAtomsPerBaseUnit: number;
    rawBaseUnitsPerBaseUnit: number;
    baseLotsPerBaseUnit: number;
    quoteLotsPerBaseUnitPerTick: number;
    priceDecimalPlaces: number;
    takerFeeBps: number;
    constructor({ address, marketSizeParams, baseParams, baseLotSize, quoteParams, quoteLotSize, tickSizeInQuoteAtomsPerBaseUnit, rawBaseUnitsPerBaseUnit, baseLotsPerBaseUnit, quoteLotsPerBaseUnitPerTick, priceDecimalPlaces, takerFeeBps, }: {
        address: PublicKey;
        marketSizeParams: MarketSizeParams;
        baseParams: TokenParams;
        baseLotSize: number;
        quoteParams: TokenParams;
        quoteLotSize: number;
        tickSizeInQuoteAtomsPerBaseUnit: number;
        rawBaseUnitsPerBaseUnit: number;
        baseLotsPerBaseUnit: number;
        quoteLotsPerBaseUnitPerTick: number;
        priceDecimalPlaces: number;
        takerFeeBps: number;
    });
    static fromMarketState(marketState: MarketState): MarketMetadata;
    /**
     * Get a trader's seat account address
     *
     * @param trader The `PublicKey` of the trader account
     */
    getSeatAddress(trader: PublicKey): PublicKey;
    /**
     * Get a trader's base ATA for a given market
     *
     * @param trader The `PublicKey` of the trader account
     */
    getBaseAccountKey(trader: PublicKey): PublicKey;
    /**
     * Get a trader's quote ATA for a given market
     *
     * @param trader The `PublicKey` of the trader account
     */
    getQuoteAccountKey(trader: PublicKey): PublicKey;
    /**
     * Get the quote vault token account address for a given market
     */
    getQuoteVaultKey(): PublicKey;
    /**
     * Get the base vault token account address for a given market
     */
    getBaseVaultKey(): PublicKey;
    /**
     * Given a price in quote units per raw base unit, returns the price in ticks.
     *
     * Example: With a market tick size of 0.01, and a price of 1.23 quote units per raw base unit, the price in ticks is 123
     *
     * @param price The price to convert
     */
    floatPriceToTicks(price: number): number;
    /**
     * Given a price in ticks, returns the price in quote units per raw base unit.
     *
     * Example: With a market tick size of 0.01, and a price of 123 ticks, the price in quote units per raw base unit is 1.23
     *
     * @param ticks The price in ticks to convert
     */
    ticksToFloatPrice(ticks: number): number;
    /**
     * Given a number of raw base units, returns the equivalent number of base lots (rounded down).
     *
     * @param rawBaseUnits The amount of raw base units to convert
     */
    rawBaseUnitsToBaseLotsRoundedDown(rawBaseUnits: number): number;
    /**
     * Given a number of raw base units, returns the equivalent number of base lots (rounded up).
     *
     * @param rawBaseUnits The amount of raw base units to convert
     */
    rawBaseUnitsToBaseLotsRoundedUp(rawBaseUnits: number): number;
    /**
     * Given a number of base atoms, returns the equivalent number of base lots.
     *
     * @param baseAtoms The amount of base atoms to convert
     */
    baseAtomsToBaseLots(baseAtoms: number): number;
    /**
     * Given a number of base lots, returns the equivalent number of base atoms.
     *
     * @param baseLots The amount of base lots to convert
     */
    baseLotsToBaseAtoms(baseLots: number): number;
    /**
     * Given a number of base lots, returns the equivalent number of raw base units.
     *
     * @param baseLots The amount of base lots to convert
     */
    baseLotsToRawBaseUnits(baseLots: number): number;
    /**
     * Given a number of quote units, returns the equivalent number of quote lots.
     *
     * @param quoteUnits The amount of quote units to convert
     */
    quoteUnitsToQuoteLots(quoteUnits: number): number;
    /**
     * Given a number of quote atoms, returns the equivalent number of quote lots.
     *
     * @param quoteAtoms The amount of quote atoms to convert
     */
    quoteAtomsToQuoteLots(quoteAtoms: number): number;
    /**
     * Given a number of quote lots, returns the equivalent number of quote atoms.
     *
     * @param quoteLots The amount of quote lots to convert
     */
    quoteLotsToQuoteAtoms(quoteLots: number): number;
    /**
     * Given a number of quote lots, returns the equivalent number of raw quote units.
     *
     * @param quoteLots The amount of quote lots to convert
     */
    quoteLotsToQuoteUnits(quoteLots: number): number;
    /**
     * Given a number of base atoms, returns the equivalent number of raw base units.
     *
     * @param baseAtoms The amount of base atoms to convert
     */
    baseAtomsToRawBaseUnits(baseAtoms: number): number;
    /**
     * Given a number of quote atoms, returns the equivalent number of quote units.
     *
     * @param quoteAtoms The amount of quote atoms to convert
     */
    quoteAtomsToQuoteUnits(quoteAtoms: number): number;
    /**
     * Instruction builders
     **/
    /**
     * Creates a _CancelAllOrders_ instruction.
     *
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelAllOrdersInstruction(trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelAllOrdersWithFreeFunds_ instruction.
     *
     * @param trader Trader public key (defaults to client's wallet public key)
     * @category Instructions
     */
    createCancelAllOrdersWithFreeFundsInstruction(trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelMultipleOrdersById_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     * @category CancelMultipleOrdersById
     */
    createCancelMultipleOrdersByIdInstruction(args: CancelMultipleOrdersByIdInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelMultipleOrdersByIdWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelMultipleOrdersByIdWithFreeFundsInstruction(args: CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelUpTo_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelUpToInstruction(args: CancelUpToInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelUpToWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelUpToWithFreeFundsInstruction(args: CancelUpToWithFreeFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _DepositFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createDepositFundsInstruction(args: DepositFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceLimitOrder_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceLimitOrderInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceLimitOrderWithFreeFunds_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceLimitOrderWithFreeFundsInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceMultiplePostOnlyOrders_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceMultiplePostOnlyOrdersInstruction(args: PlaceMultiplePostOnlyOrdersInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceMultiplePostOnlyOrdersInstructionWithFreeFunds(args: PlaceMultiplePostOnlyOrdersInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _ReduceOrder_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createReduceOrderInstruction(args: ReduceOrderInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _ReduceOrderWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createReduceOrderWithFreeFundsInstruction(args: ReduceOrderWithFreeFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _RequestSeat_ instruction.
     *
     * @param payer Payer public key
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createRequestSeatInstruction(payer: PublicKey, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _Swap_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createSwapInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _SwapWithFreeFunds_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createSwapWithFreeFundsInstruction(orderPacket: OrderPacket, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _WithdrawFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createWithdrawFundsInstruction(args: WithdrawFundsInstructionArgs, trader: PublicKey): TransactionInstruction;
    /**
     * Returns an instruction to place a limit order on a market, using a LimitOrderPacketTemplate, which takes in human-friendly units
     * @param trader The trader's address
     * @param limitOrderTemplate The order packet template to place
     * @returns
     */
    getLimitOrderInstructionfromTemplate(trader: PublicKey, limitOrderTemplate: LimitOrderTemplate): TransactionInstruction;
    /**
     * Returns an instruction to place a post only on a market, using a PostOnlyOrderPacketTemplate, which takes in human-friendly units.
     * @param trader The trader's address
     * @param postOnlyOrderTemplate The order packet template to place
     * @returns
     */
    getPostOnlyOrderInstructionfromTemplate(trader: PublicKey, postOnlyOrderTemplate: PostOnlyOrderTemplate): TransactionInstruction;
    /**
     * Returns an instruction to place an immediate or cancel on a market, using a ImmediateOrCancelPacketTemplate, which takes in human-friendly units.
     * @param trader The trader's address
     * @param immediateOrCancelOrderTemplate The order packet template to place
     * @returns
     */
    getImmediateOrCancelOrderInstructionfromTemplate(trader: PublicKey, immediateOrCancelOrderTemplate: ImmediateOrCancelOrderTemplate): TransactionInstruction;
}

type MarketConfig = {
    name: string;
    marketId: string;
    baseToken: TokenConfig;
    quoteToken: TokenConfig;
};
type TokenConfig = {
    name: string;
    symbol: string;
    mint: string;
    logoUri: string;
};
type BaseMarketConfig = {
    market: string;
    baseMint: string;
    quoteMint: string;
};
type RawMarketConfig = Record<Cluster, {
    tokens: TokenConfig[];
    markets: BaseMarketConfig[];
}>;
declare class Client {
    connection: Connection;
    cluster: Cluster;
    tokenConfigs: Map<string, TokenConfig>;
    marketStates: Map<string, MarketState>;
    marketMetadatas: Map<string, MarketMetadata>;
    marketConfigs: Map<string, MarketConfig>;
    clock: ClockData;
    private constructor();
    static createFromConfig(connection: Connection, rawMarketConfigs: RawMarketConfig, skipInitialFetch?: boolean, useZstd?: boolean): Promise<Client>;
    /**
     * Creates a new `PhoenixClient`
     *
     * @param connection The Solana `Connection` to use for the client
     * @param skipInitialFetch If true, skips the initial load of markets and tokens
     */
    static create(connection: Connection, skipInitialFetch?: boolean, configUrl?: string): Promise<Client>;
    static createWithoutConfig(connection: Connection, marketAddresses: PublicKey[], useZstd?: boolean): Promise<Client>;
    static createWithMarketAddresses(connection: Connection, marketAddresses: PublicKey[], configUrl?: string, useZstd?: boolean): Promise<Client>;
    /**
     * Add a market to the client. Useful for localnet as markets will not be loaded in by default.
     * @param marketAddress The `PublicKey` of the market account
     * @param forceReload If this is set to true, it will reload the market even if it already exists
     * @param useZstd If this is set to true, it will use zstd compression to get the market data. This is useful for fetching large accounts with a lot of repetitive data.
     */
    addMarket(marketAddress: string, forceReload?: boolean, useZstd?: boolean): Promise<void>;
    /**
     * Refreshes the market data for all markets and the clock
     * @param useZstd If this is set to true, it will use zstd compression to get the market data. This is useful for fetching large accounts with a lot of repetitive data.
     */
    refreshAllMarkets(useZstd?: boolean): Promise<void>;
    /**
     * Refreshes the market data and clock
     *
     * @param marketAddress The address of the market to refresh
     * @param useZstd If this is set to true, it will use zstd compression to get the market data. This is useful for fetching large accounts with a lot of repetitive data.
     * @returns The refreshed Market
     */
    refreshMarket(marketAddress: string | PublicKey, useZstd?: boolean): Promise<MarketState>;
    reloadClock(): Promise<void>;
    reloadClockFromBuffer(clockBuffer: Buffer): void;
    /**
     * Returns the market's ladder of bids and asks
     * @param marketAddress The `PublicKey` of the market account
     * @param levels The number of levels to return
     */
    getLadder(marketAddress: string, levels?: number): Ladder;
    /**
     * Returns the market's ladder of bids and asks as JS numbers
     * @param marketAddress The `PublicKey` of the market account
     * @param levels The number of levels to return
     */
    getUiLadder(marketAddress: string, levels?: number): UiLadder;
    /**
     * Returns the L3 book for a market. Note that the returned book will not contain expired orders.
     * To include expired orders, use `getL3BookWithParams`, with a startingValidSlot or startingUnixTimeStampInSeconds argument BEFORE the expiration slot or time.
     * @param marketAddress The `PublicKey` of the market account
     * @param ordersPerSide The number of orders to return per side
     */
    getL3Book(marketAddress: string, ordersPerSide?: number): L3Book;
    /**
     * Returns the L3 book for a market, with a starting valid slot and starting unix timestamp.
     * Time-in-force orders with a last valid slot or last valid timestamp after the specified starting slot or timestamp will be included.
     * For example, if the startingValidSlot is 0 and startingUnixTimestampInSeconds is 0, all orders, including expired ones, will be included.
     * @param marketAddress
     * @param startingValidSlot
     * @param startingUnixTimestampInSeconds
     * @param ordersPerSide
     */
    getL3BookWithParams(marketAddress: string, startingValidSlot: bignum, startingUnixTimestampInSeconds: bignum, ordersPerSide?: number): L3Book;
    /**
     * Returns the L3 UI book for a market. Note that the returned book will not contain expired orders.
     * To include expired orders, use `getL3UiBookWithParams`, with a startingValidSlot or startingUnixTimeStampInSeconds argument BEFORE the expiration slot or time.
     * @param marketAddress The `PublicKey` of the market account
     * @param ordersPerSide The number of orders to return per side
     */
    getL3UiBook(marketAddress: string, ordersPerSide?: number): L3UiBook;
    /**
     * Returns the L3 UI book for a market, with a starting valid slot and starting unix timestamp.
     * Time-in-force orders with a last valid slot or last valid timestamp after the specified starting slot or timestamp will be included.
     * For example, if the startingValidSlot is 0 and startingUnixTimestampInSeconds is 0, all orders, including expired ones, will be included.
     * @param marketAddress
     * @param startingValidSlot
     * @param startingUnixTimestampInSeconds
     * @param ordersPerSide
     * @returns
     */
    getL3UiBookWithParams(marketAddress: string, startingValidSlot: bignum, startingUnixTimestampInSeconds: bignum, ordersPerSide?: number): L3UiBook;
    /**
     * Pretty prints the market's current ladder of bids and asks
     */
    printLadder(marketAddress: string): void;
    /**
     * Returns the expected amount out for a given swap order
     *
     * @param marketAddress The `MarketAddress` for the swap market
     * @param side The side of the order (Bid or Ask)
     * @param inAmount The amount of the input token
     *
     */
    getMarketExpectedOutAmount({ marketAddress, side, inAmount, }: {
        marketAddress: string;
        side: Side;
        inAmount: number;
    }): number;
    /**
     * Get a trader's base ATA for a given market
     *
     * @param trader The `PublicKey` of the trader account
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    getBaseAccountKey(trader: PublicKey, marketAddress: string): PublicKey;
    /**
     * Get a trader's quote ATA for a given market
     *
     * @param trader The `PublicKey` of the trader account
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    getQuoteAccountKey(trader: PublicKey, marketAddress: string): PublicKey;
    /**
     * Get the quote vault address for a given market
     *
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    getQuoteVaultKey(marketAddress: string): PublicKey;
    /**
     * Get the base vault address for a given market
     *
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    getBaseVaultKey(marketAddress: string): PublicKey;
    /**
     * Get a trader's seat account Pubkey for a given market
     *
     * @param trader The `PublicKey` of the trader account
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    getSeatKey(trader: PublicKey, marketAddress: string): PublicKey;
    /**
     * Unit conversion functions
     **/
    /**
     * Given a price in quote units per raw base unit, returns the price in ticks.
     *
     * Example: With a market tick size of 0.01, and a price of 1.23 quote units per raw base unit, the price in ticks is 123
     *
     * @param price The price to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    floatPriceToTicks(price: number, marketAddress: string): number;
    /**
     * Given a price in ticks, returns the price in quote units per raw base unit.
     *
     * Example: With a market tick size of 0.01, and a price of 123 ticks, the price in quote units per raw base unit is 1.23
     *
     * @param ticks The price in ticks to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    ticksToFloatPrice(ticks: number, marketAddress: string): number;
    /**
     * Given a number of raw base units, returns the equivalent number of base lots (rounded down).
     *
     * @param rawBaseUnits The amount of raw base units to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    rawBaseUnitsToBaseLotsRoundedDown(rawBaseUnits: number, marketAddress: string): number;
    /**
     * Given a number of raw base units, returns the equivalent number of base lots (rounded up).
     *
     * @param rawBaseUnits The amount of raw base units to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    rawBaseUnitsToBaseLotsRoundedUp(rawBaseUnits: number, marketAddress: string): number;
    /**
     * Given a number of base atoms, returns the equivalent number of base lots.
     *
     * @param baseAtoms The amount of base atoms to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    baseAtomsToBaseLots(baseAtoms: number, marketAddress: string): number;
    /**
     * Given a number of base lots, returns the equivalent number of base atoms.
     *
     * @param baseLots The amount of base lots to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    baseLotsToBaseAtoms(baseLots: number, marketAddress: string): number;
    /**
     * Given a number of quote units, returns the equivalent number of quote lots.
     *
     * @param quoteUnits The amount of quote units to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    quoteUnitsToQuoteLots(quoteUnits: number, marketAddress: string): number;
    /**
     * Given a number of quote atoms, returns the equivalent number of quote lots.
     *
     * @param quoteAtoms The amount of quote atoms to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    quoteAtomsToQuoteLots(quoteAtoms: number, marketAddress: string): number;
    /**
     * Given a number of quote lots, returns the equivalent number of quote atoms.
     *
     * @param quoteLots The amount of quote lots to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    quoteLotsToQuoteAtoms(quoteLots: number, marketAddress: string): number;
    /**
     * Given a number of base atoms, returns the equivalent number of raw base units.
     *
     * @param baseAtoms The amount of base atoms to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    baseAtomsToRawBaseUnits(baseAtoms: number, marketAddress: string): number;
    /**
     * Given a number of quote atoms, returns the equivalent number of quote units.
     *
     * @param quoteAtoms The amount of quote atoms to convert
     * @param marketAddress The `PublicKey` of the market account, as a string
     */
    quoteAtomsToQuoteUnits(quoteAtoms: number, marketAddress: string): number;
    /**
     * Instruction builders
     **/
    /**
     * Creates a _CancelAllOrders_ instruction.
     *
     * @param marketAddress Market address string
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelAllOrdersInstruction(marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelAllOrdersWithFreeFunds_ instruction.
     *
     * @param marketAddress Market address string
     * @param trader Trader public key (defaults to client's wallet public key)
     * @category Instructions
     */
    createCancelAllOrdersWithFreeFundsInstruction(marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelMultipleOrdersById_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     * @category CancelMultipleOrdersById
     */
    createCancelMultipleOrdersByIdInstruction(args: CancelMultipleOrdersByIdInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelMultipleOrdersByIdWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createCancelMultipleOrdersByIdWithFreeFundsInstruction(args: CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelUpTo_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key (defaults to client's wallet public key)
     *
     * @category Instructions
     */
    createCancelUpToInstruction(args: CancelUpToInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _CancelUpToWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createCancelUpToWithFreeFundsInstruction(args: CancelUpToWithFreeFundsInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _DepositFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createDepositFundsInstruction(args: DepositFundsInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceLimitOrder_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceLimitOrderInstruction(orderPacket: OrderPacket, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceLimitOrderWithFreeFunds_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceLimitOrderWithFreeFundsInstruction(orderPacket: OrderPacket, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceMultiplePostOnlyOrders_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceMultiplePostOnlyOrdersInstruction(args: PlaceMultiplePostOnlyOrdersInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _PlaceMultiplePostOnlyOrdersWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createPlaceMultiplePostOnlyOrdersInstructionWithFreeFunds(args: PlaceMultiplePostOnlyOrdersInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _ReduceOrder_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createReduceOrderInstruction(args: ReduceOrderInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _ReduceOrderWithFreeFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createReduceOrderWithFreeFundsInstruction(args: ReduceOrderWithFreeFundsInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _RequestSeat_ instruction.
     *
     * @param marketAddress Market address string
     * @param payer Payer public key
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createRequestSeatInstruction(marketAddress: string, payer: PublicKey, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _Swap_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createSwapInstruction(orderPacket: OrderPacket, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _SwapWithFreeFunds_ instruction.
     *
     * @param orderPacket to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createSwapWithFreeFundsInstruction(orderPacket: OrderPacket, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Creates a _WithdrawFunds_ instruction.
     *
     * @param args to provide as instruction data to the program
     * @param marketAddress Market address string
     * @param trader Trader public key
     *
     * @category Instructions
     */
    createWithdrawFundsInstruction(args: WithdrawFundsInstructionArgs, marketAddress: string, trader: PublicKey): TransactionInstruction;
    /**
     * Returns an instruction to place a limit order on a market, using a LimitOrderPacketTemplate, which takes in human-friendly units
     * @param marketAddress The market's address
     * @param trader The trader's address
     * @param limitOrderTemplate The order packet template to place
     * @returns
     */
    getLimitOrderInstructionfromTemplate(marketAddress: string, trader: PublicKey, limitOrderTemplate: LimitOrderTemplate): TransactionInstruction;
    /**
     * Returns an instruction to place a post only on a market, using a PostOnlyOrderPacketTemplate, which takes in human-friendly units.
     * @param marketAddress The market's address
     * @param trader The trader's address
     * @param postOnlyOrderTemplate The order packet template to place
     * @returns
     */
    getPostOnlyOrderInstructionfromTemplate(marketAddress: string, trader: PublicKey, postOnlyOrderTemplate: PostOnlyOrderTemplate): TransactionInstruction;
    /**
     * Returns an instruction to place an immediate or cancel on a market, using a ImmediateOrCancelPacketTemplate, which takes in human-friendly units.
     * @param marketAddress The market's address
     * @param trader The trader's address
     * @param immediateOrCancelOrderTemplate The order packet template to place
     * @returns
     */
    getImmediateOrCancelOrderIxfromTemplate(marketAddress: string, trader: PublicKey, immediateOrCancelOrderTemplate: ImmediateOrCancelOrderTemplate): TransactionInstruction;
}

interface PostOnlyOrderTemplate {
    side: Side;
    priceAsFloat: number;
    sizeInBaseUnits: number;
    clientOrderId: number;
    rejectPostOnly: boolean;
    useOnlyDepositedFunds: boolean;
    lastValidSlot?: number;
    lastValidUnixTimestampInSeconds?: number;
}
interface LimitOrderTemplate {
    side: Side;
    priceAsFloat: number;
    sizeInBaseUnits: number;
    selfTradeBehavior: SelfTradeBehavior;
    matchLimit?: number;
    clientOrderId: number;
    useOnlyDepositedFunds: boolean;
    lastValidSlot?: number;
    lastValidUnixTimestampInSeconds?: number;
}
interface ImmediateOrCancelOrderTemplate {
    side: Side;
    priceAsFloat: number;
    sizeInBaseUnits: number;
    sizeInQuoteUnits: number;
    minBaseUnitsToFill: number;
    minQuoteUnitsToFill: number;
    selfTradeBehavior: SelfTradeBehavior;
    matchLimit?: number;
    clientOrderId: number;
    useOnlyDepositedFunds: boolean;
    lastValidSlot?: number;
    lastValidUnixTimestampInSeconds?: number;
}
/**
 * Returns a post only order packet.
 * @param side The side of the order
 * @param priceInTicks The price of the order in ticks
 * @param numBaseLots The number of base lots to trade
 * @param clientOrderId The client order id
 * @param rejectPostOnly Whether a post only order should be rejcted if it crosses. Default is true.
 * @param useOnlyDepositedFunds Whether to use only deposited funds
 * @param lastValidSlot The last valid slot for a time in force order
 * @param lastValidUnixTimestampInSeconds The last valid unix timestamp in seconds for a time in force order
 * @param failSilientlyOnInsufficientFunds Whether to fail silently on insufficient funds
 */
declare function getPostOnlyOrderPacket({ side, priceInTicks, numBaseLots, rejectPostOnly, clientOrderId, useOnlyDepositedFunds, lastValidSlot, lastValidUnixTimestampInSeconds, failSilientlyOnInsufficientFunds, }: {
    side: Side;
    priceInTicks: number;
    numBaseLots: number;
    rejectPostOnly?: boolean;
    clientOrderId?: number;
    useOnlyDepositedFunds?: boolean;
    lastValidSlot?: number;
    lastValidUnixTimestampInSeconds?: number;
    failSilientlyOnInsufficientFunds?: boolean;
}): OrderPacket;
/**
 * Returns a limit order packet
 * @param side The side of the order
 * @param priceInTicks The price of the order in ticks
 * @param numBaseLots The number of base lots to trade
 * @param selfTradeBehavior The self trade behavior
 * @param clientOrderId The client order id
 * @param useOnlyDepositedFunds Whether to use only deposited funds
 * @param lastValidSlot The last valid slot for a time in force order
 * @param lastValidUnixTimestampInSeconds The last valid unix timestamp in seconds for a time in force order
 * @param failSilientlyOnInsufficientFunds Whether to fail silently on insufficient funds
 */
declare function getLimitOrderPacket({ side, priceInTicks, numBaseLots, selfTradeBehavior, matchLimit, clientOrderId, useOnlyDepositedFunds, lastValidSlot, lastValidUnixTimestampInSeconds, failSilientlyOnInsufficientFunds, }: {
    side: Side;
    priceInTicks: number;
    numBaseLots: number;
    selfTradeBehavior?: SelfTradeBehavior;
    matchLimit?: number;
    clientOrderId?: number;
    useOnlyDepositedFunds?: boolean;
    lastValidSlot?: number;
    lastValidUnixTimestampInSeconds?: number;
    failSilientlyOnInsufficientFunds?: boolean;
}): OrderPacket;
/**
 * Returns an immediate-or-cancel order packet.
 * @param side The side of the order
 * @param priceInTicks The price of the order in ticks
 * @param numBaseLots The number of base lots to trade
 * @param numQuoteLots The number of quote lots to trade
 * @param minBaseLotsToFill The minimum number of base lots to fill
 * @param minQuoteLotsToFill The minimum number of quote lots to fill
 * @param selfTradeBehavior The self trade behavior
 * @param matchLimit The match limit
 * @param clientOrderId The client order id
 * @param useOnlyDepositedFunds Whether to use only deposited funds
 * @param lastValidSlot The last valid slot for a time in force order
 * @param lastValidUnixTimestampInSeconds The last valid unix timestamp in seconds for a time in force order
 */
declare function getImmediateOrCancelOrderPacket({ side, priceInTicks, numBaseLots, numQuoteLots, minBaseLotsToFill, minQuoteLotsToFill, selfTradeBehavior, matchLimit, clientOrderId, useOnlyDepositedFunds, lastValidSlot, lastValidUnixTimestampInSeconds, }: {
    side: Side;
    priceInTicks?: number;
    numBaseLots: number;
    numQuoteLots: number;
    minBaseLotsToFill?: number;
    minQuoteLotsToFill?: number;
    selfTradeBehavior?: SelfTradeBehavior;
    matchLimit?: number;
    clientOrderId?: number;
    useOnlyDepositedFunds?: boolean;
    lastValidSlot?: number;
    lastValidUnixTimestampInSeconds?: number;
}): OrderPacket;

/**
 * Program address
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ADDRESS = "PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY";
/**
 * Program public key
 *
 * @category constants
 * @category generated
 */
declare const PROGRAM_ID: PublicKey;
/**
 * Returns the Phoenix log authority Pubkey
 */
declare function getLogAuthority(): PublicKey;

export { AuditLogHeader, CancelAllOrdersInstructionAccounts, CancelAllOrdersStruct, CancelAllOrdersWithFreeFundsInstructionAccounts, CancelAllOrdersWithFreeFundsStruct, CancelMultipleOrdersByIdInstructionAccounts, CancelMultipleOrdersByIdInstructionArgs, CancelMultipleOrdersByIdParams, CancelMultipleOrdersByIdStruct, CancelMultipleOrdersByIdWithFreeFundsInstructionAccounts, CancelMultipleOrdersByIdWithFreeFundsInstructionArgs, CancelMultipleOrdersByIdWithFreeFundsStruct, CancelMultipleOrdersErrorError, CancelOrderParams, CancelUpToInstructionAccounts, CancelUpToInstructionArgs, CancelUpToParams, CancelUpToStruct, CancelUpToWithFreeFundsInstructionAccounts, CancelUpToWithFreeFundsInstructionArgs, CancelUpToWithFreeFundsStruct, Client, ClockData, Cluster, CondensedOrder, DEFAULT_L2_LADDER_DEPTH, DEFAULT_L3_BOOK_DEPTH, DEFAULT_MATCH_LIMIT, DEFAULT_SLIPPAGE_PERCENT, DepositFundsInstructionAccounts, DepositFundsInstructionArgs, DepositFundsStruct, DepositParams, EvictEvent, EvictionErrorError, ExpiredOrderEvent, FailedMultipleLimitOrderBehavior, FailedToLoadMarketFromAccountError, FeeEvent, FillEvent, FillSummaryEvent, ImmediateOrCancelOrderTemplate, InitializeParams, InvalidBaseAccountError, InvalidBaseVaultError, InvalidLotSizeError, InvalidMarketAuthorityError, InvalidMarketParametersError, InvalidMarketSignerError, InvalidMintError, InvalidQuoteAccountError, InvalidQuoteVaultError, InvalidSeatStatusError, InvalidStateTransitionError, InvalidTickSizeError, L3Book, L3Order, L3UiBook, L3UiOrder, Ladder, LadderLevel, LimitOrderTemplate, LogInstructionAccounts, LogStruct, MarketAlreadyInitializedError, MarketConfig, MarketData, MarketHeader, MarketMetadata, MarketSizeParams, MarketState, MarketStatus, MarketUninitializedError, MultipleOrderPacket, NewOrderErrorError, OrderId, OrderPacket, OrderPacketRecord, PROGRAM_ADDRESS, PROGRAM_ID, PhoenixEvents, PhoenixEventsFromInstruction, PhoenixMarketEvent, PhoenixMarketEventRecord, PhoenixTransaction, PlaceEvent, PlaceLimitOrderInstructionAccounts, PlaceLimitOrderInstructionArgs, PlaceLimitOrderStruct, PlaceLimitOrderWithFreeFundsInstructionAccounts, PlaceLimitOrderWithFreeFundsInstructionArgs, PlaceLimitOrderWithFreeFundsStruct, PlaceMultiplePostOnlyOrdersInstructionAccounts, PlaceMultiplePostOnlyOrdersInstructionArgs, PlaceMultiplePostOnlyOrdersStruct, PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionAccounts, PlaceMultiplePostOnlyOrdersWithFreeFundsInstructionArgs, PlaceMultiplePostOnlyOrdersWithFreeFundsStruct, PostOnlyOrderTemplate, RawMarketConfig, ReduceEvent, ReduceOrderErrorError, ReduceOrderInstructionAccounts, ReduceOrderInstructionArgs, ReduceOrderParams, ReduceOrderStruct, ReduceOrderWithFreeFundsInstructionAccounts, ReduceOrderWithFreeFundsInstructionArgs, ReduceOrderWithFreeFundsStruct, RemoveEmptyOrdersErrorError, RequestSeatInstructionAccounts, RequestSeatStruct, RestingOrder, Seat, SeatApprovalStatus, SeatManagerData, SelfTradeBehavior, Side, SwapInstructionAccounts, SwapInstructionArgs, SwapStruct, SwapWithFreeFundsInstructionAccounts, SwapWithFreeFundsInstructionArgs, SwapWithFreeFundsStruct, TimeInForceEvent, TokenConfig, TokenParams, TooManyEventsError, TraderNotFoundError, TraderState, UiLadder, UiLadderLevel, WithdrawFundsErrorError, WithdrawFundsInstructionAccounts, WithdrawFundsInstructionArgs, WithdrawFundsStruct, WithdrawParams, auditLogHeaderBeet, cancelAllOrdersInstructionDiscriminator, cancelAllOrdersWithFreeFundsInstructionDiscriminator, cancelMultipleOrdersByIdInstructionDiscriminator, cancelMultipleOrdersByIdParamsBeet, cancelMultipleOrdersByIdWithFreeFundsInstructionDiscriminator, cancelOrderParamsBeet, cancelUpToInstructionDiscriminator, cancelUpToParamsBeet, cancelUpToWithFreeFundsInstructionDiscriminator, clockBeet, condensedOrderBeet, confirmOrCreateClaimSeatIxs, createCancelAllOrdersInstruction, createCancelAllOrdersWithFreeFundsInstruction, createCancelMultipleOrdersByIdInstruction, createCancelMultipleOrdersByIdWithFreeFundsInstruction, createCancelUpToInstruction, createCancelUpToWithFreeFundsInstruction, createClaimSeatInstructions, createDepositFundsInstruction, createLogInstruction, createPlaceLimitOrderInstruction, createPlaceLimitOrderWithFreeFundsInstruction, createPlaceMultiplePostOnlyOrdersInstruction, createPlaceMultiplePostOnlyOrdersWithFreeFundsInstruction, createReduceOrderInstruction, createReduceOrderWithFreeFundsInstruction, createRequestSeatInstruction, createSwapInstruction, createSwapWithFreeFundsInstruction, createWithdrawFundsInstruction, decodePhoenixEvents, depositFundsInstructionDiscriminator, depositParamsBeet, deserializeClockData, deserializeMarketData, deserializeSeatManagerData, errorFromCode, errorFromName, evictEventBeet, expiredOrderEventBeet, failedMultipleLimitOrderBehaviorBeet, feeEventBeet, fillEventBeet, fillSummaryEventBeet, findTraderToEvict, getBaseAmountFromQuoteAmountBudgetAndBook, getCancelOrderParamsFromL3Order, getClaimSeatIx, getClusterFromConnection, getConfirmedMarketAccountZstd, getConfirmedMarketsAndClockAccounts, getConfirmedMarketsAndClockAccountsZstd, getCreateTokenAccountInstructions, getEventsFromTransaction, getEvictSeatIx, getExpectedOutAmountRouter, getImmediateOrCancelOrderPacket, getLimitOrderNewMakerIxs, getLimitOrderPacket, getLimitOrderUnknownSeatIxs, getLogAuthority, getMakerSetupInstructionsForMarket, getMarketL3Book, getMarketL3UiBook, getMarketLadder, getMarketSwapTransaction, getMarketUiLadder, getOrderSequenceNumberFromL3Order, getPhoenixEventsFromLogData, getPhoenixEventsFromTransactionData, getPhoenixEventsFromTransactionSignature, getPostOnlyOrderPacket, getQuoteAmountFromBaseAmountBudgetAndBook, getQuoteUnitsInFromRawBaseUnitsOut, getQuoteUnitsOutFromRawBaseUnitsIn, getRawBaseUnitsInFromQuoteUnitsOut, getRawBaseUnitsOutFromQuoteUnitsIn, getRequiredInAmountRouter, getSeatAddress, getSeatDepositCollectorAddress, getSeatManagerAddress, getUiOrderSequenceNumber, initializeParamsBeet, isOrderPacketImmediateOrCancel, isOrderPacketLimit, isOrderPacketPostOnly, isPhoenixMarketEventEvict, isPhoenixMarketEventExpiredOrder, isPhoenixMarketEventFee, isPhoenixMarketEventFill, isPhoenixMarketEventFillSummary, isPhoenixMarketEventHeader, isPhoenixMarketEventPlace, isPhoenixMarketEventReduce, isPhoenixMarketEventTimeInForce, isPhoenixMarketEventUninitialized, levelToUiLevel, logInstructionDiscriminator, marketHeaderBeet, marketSizeParamsBeet, marketStatusBeet, multipleOrderPacketBeet, orderPacketBeet, phoenixEventsBeet, phoenixMarketEventBeet, placeEventBeet, placeLimitOrderInstructionDiscriminator, placeLimitOrderWithFreeFundsInstructionDiscriminator, placeMultiplePostOnlyOrdersInstructionDiscriminator, placeMultiplePostOnlyOrdersWithFreeFundsInstructionDiscriminator, printUiLadder, readPublicKey, reduceEventBeet, reduceOrderInstructionDiscriminator, reduceOrderParamsBeet, reduceOrderWithFreeFundsInstructionDiscriminator, requestSeatInstructionDiscriminator, seatApprovalStatusBeet, seatBeet, seatManagerBeet, selfTradeBehaviorBeet, sideBeet, sign, swapInstructionDiscriminator, swapWithFreeFundsInstructionDiscriminator, timeInForceEventBeet, toBN, toNum, tokenParamsBeet, withdrawFundsInstructionDiscriminator, withdrawParamsBeet };
